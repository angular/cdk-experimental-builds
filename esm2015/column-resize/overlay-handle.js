/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive } from '@angular/core';
import { coerceCssPixelValue } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { fromEvent, Subject, merge } from 'rxjs';
import { distinctUntilChanged, filter, map, mapTo, pairwise, startWith, takeUntil, } from 'rxjs/operators';
import { _closest } from '@angular/cdk-experimental/popover-edit';
import { HEADER_CELL_SELECTOR } from './selectors';
// TODO: Take another look at using cdk drag drop. IIRC I ran into a couple
// good reasons for not using it but I don't remember what they were at this point.
/**
 * Base class for a component shown over the edge of a resizable column that is responsible
 * for handling column resize mouse events and displaying any visible UI on the column edge.
 */
export class ResizeOverlayHandle {
    constructor() {
        this.destroyed = new Subject();
    }
    ngAfterViewInit() {
        this._listenForMouseEvents();
    }
    ngOnDestroy() {
        this.destroyed.next();
        this.destroyed.complete();
    }
    _listenForMouseEvents() {
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.elementRef.nativeElement, 'mouseenter').pipe(mapTo(this.resizeRef.origin.nativeElement), takeUntil(this.destroyed)).subscribe(cell => this.eventDispatcher.headerCellHovered.next(cell));
            fromEvent(this.elementRef.nativeElement, 'mouseleave').pipe(map(event => event.relatedTarget &&
                _closest(event.relatedTarget, HEADER_CELL_SELECTOR)), takeUntil(this.destroyed)).subscribe(cell => this.eventDispatcher.headerCellHovered.next(cell));
            fromEvent(this.elementRef.nativeElement, 'mousedown')
                .pipe(takeUntil(this.destroyed)).subscribe(mousedownEvent => {
                this._dragStarted(mousedownEvent);
            });
        });
    }
    _dragStarted(mousedownEvent) {
        // Only allow dragging using the left mouse button.
        if (mousedownEvent.button !== 0) {
            return;
        }
        const mouseup = fromEvent(this.document, 'mouseup');
        const mousemove = fromEvent(this.document, 'mousemove');
        const escape = fromEvent(this.document, 'keyup')
            .pipe(filter(event => event.keyCode === ESCAPE));
        const startX = mousedownEvent.screenX;
        const initialSize = this._getOriginWidth();
        let overlayOffset = this._getOverlayOffset();
        let originOffset = this._getOriginOffset();
        let size = initialSize;
        let overshot = 0;
        this.updateResizeActive(true);
        mouseup.pipe(takeUntil(merge(escape, this.destroyed))).subscribe(({ screenX }) => {
            this._notifyResizeEnded(size, screenX !== startX);
        });
        escape.pipe(takeUntil(merge(mouseup, this.destroyed))).subscribe(() => {
            this._notifyResizeEnded(initialSize);
        });
        mousemove.pipe(map(({ screenX }) => screenX), startWith(startX), distinctUntilChanged(), pairwise(), takeUntil(merge(mouseup, escape, this.destroyed))).subscribe(([prevX, currX]) => {
            let deltaX = currX - prevX;
            // If the mouse moved further than the resize was able to match, limit the
            // movement of the overlay to match the actual size and position of the origin.
            if (overshot !== 0) {
                if (overshot < 0 && deltaX < 0 || overshot > 0 && deltaX > 0) {
                    overshot += deltaX;
                    return;
                }
                else {
                    const remainingOvershot = overshot + deltaX;
                    overshot = overshot > 0 ?
                        Math.max(remainingOvershot, 0) : Math.min(remainingOvershot, 0);
                    deltaX = remainingOvershot - overshot;
                    if (deltaX === 0) {
                        return;
                    }
                }
            }
            let computedNewSize = size + (this._isLtr() ? deltaX : -deltaX);
            computedNewSize = Math.min(Math.max(computedNewSize, this.resizeRef.minWidthPx, 0), this.resizeRef.maxWidthPx);
            this.resizeNotifier.triggerResize.next({ columnId: this.columnDef.name, size: computedNewSize, previousSize: size });
            const originNewSize = this._getOriginWidth();
            const originNewOffset = this._getOriginOffset();
            const originOffsetDeltaX = originNewOffset - originOffset;
            const originSizeDeltaX = originNewSize - size;
            size = originNewSize;
            originOffset = originNewOffset;
            overshot += deltaX + (this._isLtr() ? -originSizeDeltaX : originSizeDeltaX);
            overlayOffset += originOffsetDeltaX + (this._isLtr() ? originSizeDeltaX : 0);
            this._updateOverlayOffset(overlayOffset);
        });
    }
    updateResizeActive(active) {
        this.eventDispatcher.overlayHandleActiveForCell.next(active ? this.resizeRef.origin.nativeElement : null);
    }
    _getOriginWidth() {
        return this.resizeRef.origin.nativeElement.offsetWidth;
    }
    _getOriginOffset() {
        return this.resizeRef.origin.nativeElement.offsetLeft;
    }
    _getOverlayOffset() {
        return parseInt(this.resizeRef.overlayRef.overlayElement.style.left, 10);
    }
    _updateOverlayOffset(offset) {
        this.resizeRef.overlayRef.overlayElement.style.left = coerceCssPixelValue(offset);
    }
    _isLtr() {
        return this.directionality.value === 'ltr';
    }
    _notifyResizeEnded(size, completedSuccessfully = false) {
        this.updateResizeActive(false);
        this.ngZone.run(() => {
            const sizeMessage = { columnId: this.columnDef.name, size };
            if (completedSuccessfully) {
                this.resizeNotifier.resizeCompleted.next(sizeMessage);
            }
            else {
                this.resizeNotifier.resizeCanceled.next(sizeMessage);
            }
        });
    }
}
ResizeOverlayHandle.decorators = [
    { type: Directive }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1oYW5kbGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvY2RrLWV4cGVyaW1lbnRhbC9jb2x1bW4tcmVzaXplL292ZXJsYXktaGFuZGxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBZ0IsU0FBUyxFQUFnQyxNQUFNLGVBQWUsQ0FBQztBQUN0RixPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFN0MsT0FBTyxFQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQy9DLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsTUFBTSxFQUNOLEdBQUcsRUFDSCxLQUFLLEVBQ0wsUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEdBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sd0NBQXdDLENBQUM7QUFFaEUsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sYUFBYSxDQUFDO0FBS2pELDJFQUEyRTtBQUMzRSxtRkFBbUY7QUFDbkY7OztHQUdHO0FBRUgsTUFBTSxPQUFnQixtQkFBbUI7SUFEekM7UUFFcUIsY0FBUyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7SUEwSnJELENBQUM7SUEvSUMsZUFBZTtRQUNiLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFTyxxQkFBcUI7UUFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDakMs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Q0FBQyxXQUFXLENBQUMsQ0FBQzthQUN2RDtpQkFBTTtnQkFDTCxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDdEQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7OztZQTNKRixTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE5nWm9uZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2NvZXJjZUNzc1BpeGVsVmFsdWV9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge0RpcmVjdGlvbmFsaXR5fSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQge0VTQ0FQRX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7Q2RrQ29sdW1uRGVmfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHtmcm9tRXZlbnQsIFN1YmplY3QsIG1lcmdlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWFwVG8sXG4gIHBhaXJ3aXNlLFxuICBzdGFydFdpdGgsXG4gIHRha2VVbnRpbCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge19jbG9zZXN0fSBmcm9tICdAYW5ndWxhci9jZGstZXhwZXJpbWVudGFsL3BvcG92ZXItZWRpdCc7XG5cbmltcG9ydCB7SEVBREVSX0NFTExfU0VMRUNUT1J9IGZyb20gJy4vc2VsZWN0b3JzJztcbmltcG9ydCB7Q29sdW1uUmVzaXplTm90aWZpZXJTb3VyY2V9IGZyb20gJy4vY29sdW1uLXJlc2l6ZS1ub3RpZmllcic7XG5pbXBvcnQge0hlYWRlclJvd0V2ZW50RGlzcGF0Y2hlcn0gZnJvbSAnLi9ldmVudC1kaXNwYXRjaGVyJztcbmltcG9ydCB7UmVzaXplUmVmfSBmcm9tICcuL3Jlc2l6ZS1yZWYnO1xuXG4vLyBUT0RPOiBUYWtlIGFub3RoZXIgbG9vayBhdCB1c2luZyBjZGsgZHJhZyBkcm9wLiBJSVJDIEkgcmFuIGludG8gYSBjb3VwbGVcbi8vIGdvb2QgcmVhc29ucyBmb3Igbm90IHVzaW5nIGl0IGJ1dCBJIGRvbid0IHJlbWVtYmVyIHdoYXQgdGhleSB3ZXJlIGF0IHRoaXMgcG9pbnQuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGEgY29tcG9uZW50IHNob3duIG92ZXIgdGhlIGVkZ2Ugb2YgYSByZXNpemFibGUgY29sdW1uIHRoYXQgaXMgcmVzcG9uc2libGVcbiAqIGZvciBoYW5kbGluZyBjb2x1bW4gcmVzaXplIG1vdXNlIGV2ZW50cyBhbmQgZGlzcGxheWluZyBhbnkgdmlzaWJsZSBVSSBvbiB0aGUgY29sdW1uIGVkZ2UuXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlc2l6ZU92ZXJsYXlIYW5kbGUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgY29sdW1uRGVmOiBDZGtDb2x1bW5EZWY7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBkaXJlY3Rpb25hbGl0eTogRGlyZWN0aW9uYWxpdHk7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgZXZlbnREaXNwYXRjaGVyOiBIZWFkZXJSb3dFdmVudERpc3BhdGNoZXI7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBuZ1pvbmU6IE5nWm9uZTtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IHJlc2l6ZU5vdGlmaWVyOiBDb2x1bW5SZXNpemVOb3RpZmllclNvdXJjZTtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IHJlc2l6ZVJlZjogUmVzaXplUmVmO1xuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9saXN0ZW5Gb3JNb3VzZUV2ZW50cygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcml2YXRlIF9saXN0ZW5Gb3JNb3VzZUV2ZW50cygpIHtcbiAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQhLCAnbW91c2VlbnRlcicpLnBpcGUoXG4gICAgICAgICAgbWFwVG8odGhpcy5yZXNpemVSZWYub3JpZ2luLm5hdGl2ZUVsZW1lbnQhKSxcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpLFxuICAgICAgKS5zdWJzY3JpYmUoY2VsbCA9PiB0aGlzLmV2ZW50RGlzcGF0Y2hlci5oZWFkZXJDZWxsSG92ZXJlZC5uZXh0KGNlbGwpKTtcblxuICAgICAgZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ISwgJ21vdXNlbGVhdmUnKS5waXBlKFxuICAgICAgICAgIG1hcChldmVudCA9PiBldmVudC5yZWxhdGVkVGFyZ2V0ICYmXG4gICAgICAgICAgICAgIF9jbG9zZXN0KGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgRWxlbWVudCwgSEVBREVSX0NFTExfU0VMRUNUT1IpKSxcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpXG4gICAgICApLnN1YnNjcmliZShjZWxsID0+IHRoaXMuZXZlbnREaXNwYXRjaGVyLmhlYWRlckNlbGxIb3ZlcmVkLm5leHQoY2VsbCkpO1xuXG4gICAgICBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQhLCAnbW91c2Vkb3duJylcbiAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQpKS5zdWJzY3JpYmUobW91c2Vkb3duRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRlZChtb3VzZWRvd25FdmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2RyYWdTdGFydGVkKG1vdXNlZG93bkV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgLy8gT25seSBhbGxvdyBkcmFnZ2luZyB1c2luZyB0aGUgbGVmdCBtb3VzZSBidXR0b24uXG4gICAgaWYgKG1vdXNlZG93bkV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdXNldXAgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5kb2N1bWVudCwgJ21vdXNldXAnKTtcbiAgICBjb25zdCBtb3VzZW1vdmUgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5kb2N1bWVudCwgJ21vdXNlbW92ZScpO1xuICAgIGNvbnN0IGVzY2FwZSA9IGZyb21FdmVudDxLZXlib2FyZEV2ZW50Pih0aGlzLmRvY3VtZW50LCAna2V5dXAnKVxuICAgICAgICAucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFKSk7XG5cbiAgICBjb25zdCBzdGFydFggPSBtb3VzZWRvd25FdmVudC5zY3JlZW5YO1xuXG4gICAgY29uc3QgaW5pdGlhbFNpemUgPSB0aGlzLl9nZXRPcmlnaW5XaWR0aCgpO1xuICAgIGxldCBvdmVybGF5T2Zmc2V0ID0gdGhpcy5fZ2V0T3ZlcmxheU9mZnNldCgpO1xuICAgIGxldCBvcmlnaW5PZmZzZXQgPSB0aGlzLl9nZXRPcmlnaW5PZmZzZXQoKTtcbiAgICBsZXQgc2l6ZSA9IGluaXRpYWxTaXplO1xuICAgIGxldCBvdmVyc2hvdCA9IDA7XG5cbiAgICB0aGlzLnVwZGF0ZVJlc2l6ZUFjdGl2ZSh0cnVlKTtcblxuICAgIG1vdXNldXAucGlwZSh0YWtlVW50aWwobWVyZ2UoZXNjYXBlLCB0aGlzLmRlc3Ryb3llZCkpKS5zdWJzY3JpYmUoKHtzY3JlZW5YfSkgPT4ge1xuICAgICAgdGhpcy5fbm90aWZ5UmVzaXplRW5kZWQoc2l6ZSwgc2NyZWVuWCAhPT0gc3RhcnRYKTtcbiAgICB9KTtcblxuICAgIGVzY2FwZS5waXBlKHRha2VVbnRpbChtZXJnZShtb3VzZXVwLCB0aGlzLmRlc3Ryb3llZCkpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5fbm90aWZ5UmVzaXplRW5kZWQoaW5pdGlhbFNpemUpO1xuICAgIH0pO1xuXG4gICAgbW91c2Vtb3ZlLnBpcGUoXG4gICAgICAgIG1hcCgoe3NjcmVlblh9KSA9PiBzY3JlZW5YKSxcbiAgICAgICAgc3RhcnRXaXRoKHN0YXJ0WCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIHBhaXJ3aXNlKCksXG4gICAgICAgIHRha2VVbnRpbChtZXJnZShtb3VzZXVwLCBlc2NhcGUsIHRoaXMuZGVzdHJveWVkKSlcbiAgICApLnN1YnNjcmliZSgoW3ByZXZYLCBjdXJyWF0pID0+IHtcbiAgICAgIGxldCBkZWx0YVggPSBjdXJyWCAtIHByZXZYO1xuXG4gICAgICAvLyBJZiB0aGUgbW91c2UgbW92ZWQgZnVydGhlciB0aGFuIHRoZSByZXNpemUgd2FzIGFibGUgdG8gbWF0Y2gsIGxpbWl0IHRoZVxuICAgICAgLy8gbW92ZW1lbnQgb2YgdGhlIG92ZXJsYXkgdG8gbWF0Y2ggdGhlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luLlxuICAgICAgaWYgKG92ZXJzaG90ICE9PSAwKSB7XG4gICAgICAgIGlmIChvdmVyc2hvdCA8IDAgJiYgZGVsdGFYIDwgMCB8fCBvdmVyc2hvdCA+IDAgJiYgZGVsdGFYID4gMCkge1xuICAgICAgICAgIG92ZXJzaG90ICs9IGRlbHRhWDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nT3ZlcnNob3QgPSBvdmVyc2hvdCArIGRlbHRhWDtcbiAgICAgICAgICBvdmVyc2hvdCA9IG92ZXJzaG90ID4gMCA/XG4gICAgICAgICAgICAgIE1hdGgubWF4KHJlbWFpbmluZ092ZXJzaG90LCAwKSA6IE1hdGgubWluKHJlbWFpbmluZ092ZXJzaG90LCAwKTtcbiAgICAgICAgICBkZWx0YVggPSByZW1haW5pbmdPdmVyc2hvdCAtIG92ZXJzaG90O1xuXG4gICAgICAgICAgaWYgKGRlbHRhWCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgY29tcHV0ZWROZXdTaXplOiBudW1iZXIgPSBzaXplICsgKHRoaXMuX2lzTHRyKCkgPyBkZWx0YVggOiAtZGVsdGFYKTtcbiAgICAgIGNvbXB1dGVkTmV3U2l6ZSA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KGNvbXB1dGVkTmV3U2l6ZSwgdGhpcy5yZXNpemVSZWYubWluV2lkdGhQeCwgMCksIHRoaXMucmVzaXplUmVmLm1heFdpZHRoUHgpO1xuXG4gICAgICB0aGlzLnJlc2l6ZU5vdGlmaWVyLnRyaWdnZXJSZXNpemUubmV4dChcbiAgICAgICAgICB7Y29sdW1uSWQ6IHRoaXMuY29sdW1uRGVmLm5hbWUsIHNpemU6IGNvbXB1dGVkTmV3U2l6ZSwgcHJldmlvdXNTaXplOiBzaXplfSk7XG5cbiAgICAgIGNvbnN0IG9yaWdpbk5ld1NpemUgPSB0aGlzLl9nZXRPcmlnaW5XaWR0aCgpO1xuICAgICAgY29uc3Qgb3JpZ2luTmV3T2Zmc2V0ID0gdGhpcy5fZ2V0T3JpZ2luT2Zmc2V0KCk7XG4gICAgICBjb25zdCBvcmlnaW5PZmZzZXREZWx0YVggPSBvcmlnaW5OZXdPZmZzZXQgLSBvcmlnaW5PZmZzZXQ7XG4gICAgICBjb25zdCBvcmlnaW5TaXplRGVsdGFYID0gb3JpZ2luTmV3U2l6ZSAtIHNpemU7XG4gICAgICBzaXplID0gb3JpZ2luTmV3U2l6ZTtcbiAgICAgIG9yaWdpbk9mZnNldCA9IG9yaWdpbk5ld09mZnNldDtcblxuICAgICAgb3ZlcnNob3QgKz0gZGVsdGFYICsgKHRoaXMuX2lzTHRyKCkgPyAtb3JpZ2luU2l6ZURlbHRhWCA6IG9yaWdpblNpemVEZWx0YVgpO1xuICAgICAgb3ZlcmxheU9mZnNldCArPSBvcmlnaW5PZmZzZXREZWx0YVggKyAodGhpcy5faXNMdHIoKSA/IG9yaWdpblNpemVEZWx0YVggOiAwKTtcblxuICAgICAgdGhpcy5fdXBkYXRlT3ZlcmxheU9mZnNldChvdmVybGF5T2Zmc2V0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVSZXNpemVBY3RpdmUoYWN0aXZlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudERpc3BhdGNoZXIub3ZlcmxheUhhbmRsZUFjdGl2ZUZvckNlbGwubmV4dChcbiAgICAgICAgYWN0aXZlID8gdGhpcy5yZXNpemVSZWYub3JpZ2luLm5hdGl2ZUVsZW1lbnQhIDogbnVsbCk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPcmlnaW5XaWR0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlc2l6ZVJlZi5vcmlnaW4ubmF0aXZlRWxlbWVudCEub2Zmc2V0V2lkdGg7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPcmlnaW5PZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZXNpemVSZWYub3JpZ2luLm5hdGl2ZUVsZW1lbnQhLm9mZnNldExlZnQ7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPdmVybGF5T2Zmc2V0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMucmVzaXplUmVmLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQuc3R5bGUubGVmdCEsIDEwKTtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZU92ZXJsYXlPZmZzZXQob2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2l6ZVJlZi5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LnN0eWxlLmxlZnQgPSBjb2VyY2VDc3NQaXhlbFZhbHVlKG9mZnNldCk7XG4gIH1cblxuICBwcml2YXRlIF9pc0x0cigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25hbGl0eS52YWx1ZSA9PT0gJ2x0cic7XG4gIH1cblxuICBwcml2YXRlIF9ub3RpZnlSZXNpemVFbmRlZChzaXplOiBudW1iZXIsIGNvbXBsZXRlZFN1Y2Nlc3NmdWxseSA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVSZXNpemVBY3RpdmUoZmFsc2UpO1xuXG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHNpemVNZXNzYWdlID0ge2NvbHVtbklkOiB0aGlzLmNvbHVtbkRlZi5uYW1lLCBzaXplfTtcbiAgICAgIGlmIChjb21wbGV0ZWRTdWNjZXNzZnVsbHkpIHtcbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmllci5yZXNpemVDb21wbGV0ZWQubmV4dChzaXplTWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2l6ZU5vdGlmaWVyLnJlc2l6ZUNhbmNlbGVkLm5leHQoc2l6ZU1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=