{"version":3,"file":"popover-edit.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/constants.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/edit-event-dispatcher.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/edit-ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/focus-dispatcher.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/form-value-container.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/lens-directives.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/edit-services.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/focus-escape-notifier.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/table-directives.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/popover-edit/popover-edit-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Selector for finding table cells. */\nexport const CELL_SELECTOR = '.cdk-cell, .mat-cell, td';\n\n/** Selector for finding editable table cells. */\nexport const EDITABLE_CELL_SELECTOR = '.cdk-popover-edit-cell, .mat-popover-edit-cell';\n\n/** Selector for finding table rows. */\nexport const ROW_SELECTOR = '.cdk-row, .mat-row, tr';\n\n/** Selector for finding the table element. */\nexport const TABLE_SELECTOR = 'table, cdk-table, mat-table';\n\n/** CSS class added to the edit lens pane. */\nexport const EDIT_PANE_CLASS = 'cdk-edit-pane';\n\n/** Selector for finding the edit lens pane. */\nexport const EDIT_PANE_SELECTOR = `.${EDIT_PANE_CLASS}, .mat-edit-pane`;\n\n/** Selector for table rows that should be skipped when moving focus. */\nexport const SKIP_ROW_FOCUS_SELECTOR = '.cdk-popover-edit-skip-focus, .mat-popover-edit-skip-focus';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, NgZone, inject} from '@angular/core';\nimport {combineLatest, MonoTypeOperatorFunction, Observable, pipe, Subject} from 'rxjs';\nimport {\n  audit,\n  auditTime,\n  debounceTime,\n  distinctUntilChanged,\n  filter,\n  map,\n  skip,\n  startWith,\n  shareReplay,\n} from 'rxjs/operators';\n\nimport {CELL_SELECTOR, ROW_SELECTOR} from './constants';\nimport {closest} from './polyfill';\n\n/** The delay applied to mouse events before hiding or showing hover content. */\nconst MOUSE_EVENT_DELAY_MS = 40;\n\n/** The delay for reacting to focus/blur changes. */\nconst FOCUS_DELAY = 0;\n\n/**\n * The possible states for hover content:\n * OFF - Not rendered.\n * FOCUSABLE - Rendered in the dom and styled for its contents to be focusable but invisible.\n * ON - Rendered and fully visible.\n */\nexport enum HoverContentState {\n  OFF = 0,\n  FOCUSABLE,\n  ON,\n}\n\n// Note: this class is generic, rather than referencing EditRef directly, in order to avoid\n// circular imports. If we were to reference it here, importing the registry into the\n// class that is registering itself will introduce a circular import.\n\n/**\n * Service for sharing delegated events and state for triggering table edits.\n */\n@Injectable()\nexport class EditEventDispatcher<R> {\n  private readonly _ngZone = inject(NgZone);\n\n  /** A subject that indicates which table cell is currently editing (unless it is disabled). */\n  readonly editing = new Subject<Element | null>();\n\n  /** A subject that indicates which table row is currently hovered. */\n  readonly hovering = new Subject<Element | null>();\n\n  /** A subject that indicates which table row currently contains focus. */\n  readonly focused = new Subject<Element | null>();\n\n  /** A subject that indicates all elements in the table matching ROW_SELECTOR. */\n  readonly allRows = new Subject<NodeList>();\n\n  /** A subject that emits mouse move events from the table indicating the targeted row. */\n  readonly mouseMove = new Subject<Element | null>();\n\n  // TODO: Use WeakSet once IE11 support is dropped.\n  /**\n   * Tracks the currently disabled editable cells - edit calls will be ignored\n   * for these cells.\n   */\n  readonly disabledCells = new WeakMap<Element, boolean>();\n\n  /** The EditRef for the currently active edit lens (if any). */\n  get editRef(): R | null {\n    return this._editRef;\n  }\n  private _editRef: R | null = null;\n\n  // Optimization: Precompute common pipeable operators used per row/cell.\n  private readonly _distinctUntilChanged = distinctUntilChanged<\n    Element | HoverContentState | boolean | null\n  >();\n  private readonly _startWithNull = startWith<Element | null>(null);\n  private readonly _distinctShare = pipe(\n    this._distinctUntilChanged as MonoTypeOperatorFunction<HoverContentState>,\n    shareReplay(1),\n  );\n  private readonly _startWithNullDistinct = pipe(\n    this._startWithNull,\n    this._distinctUntilChanged as MonoTypeOperatorFunction<Element | null>,\n  );\n\n  readonly editingAndEnabled = this.editing.pipe(\n    filter(cell => cell == null || !this.disabledCells.has(cell)),\n    shareReplay(1),\n  );\n\n  /** An observable that emits the row containing focus or an active edit. */\n  readonly editingOrFocused = combineLatest([\n    this.editingAndEnabled.pipe(\n      map(cell => closest(cell, ROW_SELECTOR)),\n      this._startWithNull,\n    ),\n    this.focused.pipe(this._startWithNull),\n  ]).pipe(\n    map(([editingRow, focusedRow]) => focusedRow || editingRow),\n    this._distinctUntilChanged as MonoTypeOperatorFunction<Element | null>,\n    auditTime(FOCUS_DELAY), // Use audit to skip over blur events to the next focused element.\n    this._distinctUntilChanged as MonoTypeOperatorFunction<Element | null>,\n    shareReplay(1),\n  );\n\n  /** Tracks rows that contain hover content with a reference count. */\n  private _rowsWithHoverContent = new WeakMap<Element, number>();\n\n  /** The table cell that has an active edit lens (or null). */\n  private _currentlyEditing: Element | null = null;\n\n  /** The combined set of row hover content states organized by row. */\n  private readonly _hoveredContentStateDistinct = combineLatest([\n    this._getFirstRowWithHoverContent(),\n    this._getLastRowWithHoverContent(),\n    this.editingOrFocused,\n    this.hovering.pipe(\n      distinctUntilChanged(),\n      audit(row =>\n        this.mouseMove.pipe(\n          filter(mouseMoveRow => row === mouseMoveRow),\n          this._startWithNull,\n          debounceTime(MOUSE_EVENT_DELAY_MS),\n        ),\n      ),\n      this._startWithNullDistinct,\n    ),\n  ]).pipe(\n    skip(1), // Skip the initial emission of [null, null, null, null].\n    map(computeHoverContentState),\n    distinctUntilChanged(areMapEntriesEqual),\n    // Optimization: Enter the zone before shareReplay so that we trigger a single\n    // ApplicationRef.tick for all row updates.\n    this._enterZone(),\n    shareReplay(1),\n  );\n\n  private readonly _editingAndEnabledDistinct = this.editingAndEnabled.pipe(\n    distinctUntilChanged(),\n    this._enterZone(),\n    shareReplay(1),\n  );\n\n  // Optimization: Share row events observable with subsequent callers.\n  // At startup, calls will be sequential by row.\n  private _lastSeenRow: Element | null = null;\n  private _lastSeenRowHoverOrFocus: Observable<HoverContentState> | null = null;\n\n  constructor() {\n    this._editingAndEnabledDistinct.subscribe(cell => {\n      this._currentlyEditing = cell;\n    });\n  }\n\n  /**\n   * Gets an Observable that emits true when the specified element's cell\n   * is editing and false when not.\n   */\n  editingCell(element: Element | EventTarget): Observable<boolean> {\n    let cell: Element | null = null;\n\n    return this._editingAndEnabledDistinct.pipe(\n      map(editCell => editCell === (cell || (cell = closest(element, CELL_SELECTOR)))),\n      this._distinctUntilChanged as MonoTypeOperatorFunction<boolean>,\n    );\n  }\n\n  /**\n   * Stops editing for the specified cell. If the specified cell is not the current\n   * edit cell, does nothing.\n   */\n  doneEditingCell(element: Element | EventTarget): void {\n    const cell = closest(element, CELL_SELECTOR);\n\n    if (this._currentlyEditing === cell) {\n      this.editing.next(null);\n    }\n  }\n\n  /** Sets the currently active EditRef. */\n  setActiveEditRef(ref: R) {\n    this._editRef = ref;\n  }\n\n  /** Unset the currently active EditRef, if the specified editRef is active. */\n  unsetActiveEditRef(ref: R) {\n    if (this._editRef !== ref) {\n      return;\n    }\n\n    this._editRef = null;\n  }\n\n  /** Adds the specified table row to be tracked for first/last row comparisons. */\n  registerRowWithHoverContent(row: Element): void {\n    this._rowsWithHoverContent.set(row, (this._rowsWithHoverContent.get(row) || 0) + 1);\n  }\n\n  /**\n   * Reference decrements and ultimately removes the specified table row from first/last row\n   * comparisons.\n   */\n  deregisterRowWithHoverContent(row: Element): void {\n    const refCount = this._rowsWithHoverContent.get(row) || 0;\n\n    if (refCount <= 1) {\n      this._rowsWithHoverContent.delete(row);\n    } else {\n      this._rowsWithHoverContent.set(row, refCount - 1);\n    }\n  }\n\n  /**\n   * Gets an Observable that emits true when the specified element's row\n   * contains the focused element or is being hovered over and false when not.\n   * Hovering is defined as when the mouse has momentarily stopped moving over the cell.\n   */\n  hoverOrFocusOnRow(row: Element): Observable<HoverContentState> {\n    if (row !== this._lastSeenRow) {\n      this._lastSeenRow = row;\n      this._lastSeenRowHoverOrFocus = this._hoveredContentStateDistinct.pipe(\n        map(state => state.get(row) || HoverContentState.OFF),\n        this._distinctShare,\n      );\n    }\n\n    return this._lastSeenRowHoverOrFocus!;\n  }\n\n  /**\n   * RxJS operator that enters the Angular zone, used to reduce boilerplate in\n   * re-entering the zone for stream pipelines.\n   */\n  private _enterZone<T>(): MonoTypeOperatorFunction<T> {\n    return (source: Observable<T>) =>\n      new Observable<T>(observer =>\n        source.subscribe({\n          next: value => this._ngZone.run(() => observer.next(value)),\n          error: err => observer.error(err),\n          complete: () => observer.complete(),\n        }),\n      );\n  }\n\n  private _getFirstRowWithHoverContent(): Observable<Element | null> {\n    return this._mapAllRowsToSingleRow(rows => {\n      for (let i = 0, row; (row = rows[i]); i++) {\n        if (this._rowsWithHoverContent.has(row as Element)) {\n          return row as Element;\n        }\n      }\n      return null;\n    });\n  }\n\n  private _getLastRowWithHoverContent(): Observable<Element | null> {\n    return this._mapAllRowsToSingleRow(rows => {\n      for (let i = rows.length - 1, row; (row = rows[i]); i--) {\n        if (this._rowsWithHoverContent.has(row as Element)) {\n          return row as Element;\n        }\n      }\n      return null;\n    });\n  }\n\n  private _mapAllRowsToSingleRow(\n    mapper: (rows: NodeList) => Element | null,\n  ): Observable<Element | null> {\n    return this.allRows.pipe(map(mapper), this._startWithNullDistinct);\n  }\n}\n\nfunction computeHoverContentState([\n  firstRow,\n  lastRow,\n  activeRow,\n  hoverRow,\n]: (Element | null)[]): Map<Element, HoverContentState> {\n  const hoverContentState = new Map<Element, HoverContentState>();\n\n  // Add focusable rows.\n  for (const focussableRow of [\n    firstRow,\n    lastRow,\n    activeRow && activeRow.previousElementSibling,\n    activeRow && activeRow.nextElementSibling,\n  ]) {\n    if (focussableRow) {\n      hoverContentState.set(focussableRow as Element, HoverContentState.FOCUSABLE);\n    }\n  }\n\n  // Add/overwrite with fully visible rows.\n  for (const onRow of [activeRow, hoverRow]) {\n    if (onRow) {\n      hoverContentState.set(onRow, HoverContentState.ON);\n    }\n  }\n\n  return hoverContentState;\n}\n\nfunction areMapEntriesEqual<K, V>(a: Map<K, V>, b: Map<K, V>): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  // TODO: use Map.prototype.entries once we're off IE11.\n  for (const aKey of Array.from(a.keys())) {\n    if (b.get(aKey) !== a.get(aKey)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, OnDestroy, afterNextRender, inject, Injector} from '@angular/core';\nimport {ControlContainer} from '@angular/forms';\nimport {Observable, Subject} from 'rxjs';\n\nimport {EditEventDispatcher} from './edit-event-dispatcher';\n\n/**\n * Used for communication between the form within the edit lens and the\n * table that launched it. Provided by CdkEditControl within the lens.\n */\n@Injectable()\nexport class EditRef<FormValue> implements OnDestroy {\n  private readonly _form = inject(ControlContainer, {self: true});\n  private readonly _editEventDispatcher =\n    inject<EditEventDispatcher<EditRef<FormValue>>>(EditEventDispatcher);\n\n  /** Emits the final value of this edit instance before closing. */\n  private readonly _finalValueSubject = new Subject<FormValue>();\n  readonly finalValue: Observable<FormValue> = this._finalValueSubject;\n\n  /** Emits when the user tabs out of this edit lens before closing. */\n  private readonly _blurredSubject = new Subject<void>();\n  readonly blurred: Observable<void> = this._blurredSubject;\n\n  /** The value to set the form back to on revert. */\n  private _revertFormValue: FormValue;\n\n  private _injector = inject(Injector);\n\n  constructor() {\n    this._editEventDispatcher.setActiveEditRef(this);\n  }\n\n  /**\n   * Called by the host directive's OnInit hook. Reads the initial state of the\n   * form and overrides it with persisted state from previous openings, if\n   * applicable.\n   */\n  init(previousFormValue: FormValue | undefined): void {\n    // Wait for the next render before caching the initial value.\n    // This ensures that all form controls have been initialized.\n    afterNextRender(\n      () => {\n        this.updateRevertValue();\n        if (previousFormValue) {\n          this.reset(previousFormValue);\n        }\n      },\n      {injector: this._injector},\n    );\n  }\n\n  ngOnDestroy(): void {\n    this._editEventDispatcher.unsetActiveEditRef(this);\n    this._finalValueSubject.next(this._form.value);\n    this._finalValueSubject.complete();\n  }\n\n  /** Whether the attached form is in a valid state. */\n  isValid(): boolean | null {\n    return this._form.valid;\n  }\n\n  /** Set the form's current value as what it will be set to on revert/reset. */\n  updateRevertValue(): void {\n    this._revertFormValue = this._form.value;\n  }\n\n  /** Tells the table to close the edit popup. */\n  close(): void {\n    this._editEventDispatcher.editing.next(null);\n  }\n\n  /** Notifies the active edit that the user has moved focus out of the lens. */\n  blur(): void {\n    this._blurredSubject.next();\n  }\n\n  /**\n   * Resets the form value to the specified value or the previously set\n   * revert value.\n   */\n  reset(value?: FormValue): void {\n    this._form.reset(value || this._revertFormValue);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {LEFT_ARROW, UP_ARROW, RIGHT_ARROW, DOWN_ARROW} from '@angular/cdk/keycodes';\nimport {Injectable, inject} from '@angular/core';\nimport {PartialObserver} from 'rxjs';\n\nimport {\n  EDITABLE_CELL_SELECTOR,\n  ROW_SELECTOR,\n  SKIP_ROW_FOCUS_SELECTOR,\n  TABLE_SELECTOR,\n} from './constants';\nimport {closest} from './polyfill';\n\n/**\n * Service responsible for moving cell focus around in response to keyboard events.\n * May be overridden to customize the keyboard behavior of popover edit.\n */\n@Injectable({providedIn: 'root'})\nexport class FocusDispatcher {\n  protected readonly directionality = inject(Directionality);\n\n  /** Observes keydown events triggered from the table. */\n  readonly keyObserver: PartialObserver<KeyboardEvent>;\n\n  constructor() {\n    this.keyObserver = {next: event => this.handleKeyboardEvent(event)};\n  }\n\n  /**\n   * Moves focus to earlier or later cells (in dom order) by offset cells relative to\n   * currentCell.\n   */\n  moveFocusHorizontally(currentCell: HTMLElement, offset: number): void {\n    const cells = Array.from(\n      closest(currentCell, TABLE_SELECTOR)!.querySelectorAll(EDITABLE_CELL_SELECTOR),\n    ) as HTMLElement[];\n    const currentIndex = cells.indexOf(currentCell);\n    const newIndex = currentIndex + offset;\n\n    if (cells[newIndex]) {\n      cells[newIndex].focus();\n    }\n  }\n\n  /** Moves focus to up or down by row by offset cells relative to currentCell. */\n  moveFocusVertically(currentCell: HTMLElement, offset: number): void {\n    const currentRow = closest(currentCell, ROW_SELECTOR)!;\n    const rows = Array.from(closest(currentRow, TABLE_SELECTOR)!.querySelectorAll(ROW_SELECTOR));\n    const currentRowIndex = rows.indexOf(currentRow);\n    const currentIndexWithinRow = Array.from(\n      currentRow.querySelectorAll(EDITABLE_CELL_SELECTOR),\n    ).indexOf(currentCell);\n\n    let newRowIndex = currentRowIndex + offset;\n    while (rows[newRowIndex]?.matches(SKIP_ROW_FOCUS_SELECTOR)) {\n      newRowIndex = newRowIndex + (offset > 0 ? 1 : -1);\n    }\n\n    if (rows[newRowIndex]) {\n      const rowToFocus = Array.from(\n        rows[newRowIndex].querySelectorAll(EDITABLE_CELL_SELECTOR),\n      ) as HTMLElement[];\n\n      if (rowToFocus[currentIndexWithinRow]) {\n        rowToFocus[currentIndexWithinRow].focus();\n      }\n    }\n  }\n\n  /** Translates arrow keydown events into focus move operations. */\n  protected handleKeyboardEvent(event: KeyboardEvent): void {\n    const cell = closest(event.target, EDITABLE_CELL_SELECTOR) as HTMLElement | null;\n\n    if (!cell) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case UP_ARROW:\n        this.moveFocusVertically(cell, -1);\n        break;\n      case DOWN_ARROW:\n        this.moveFocusVertically(cell, 1);\n        break;\n      case LEFT_ARROW:\n        this.moveFocusHorizontally(cell, this.directionality.value === 'ltr' ? -1 : 1);\n        break;\n      case RIGHT_ARROW:\n        this.moveFocusHorizontally(cell, this.directionality.value === 'ltr' ? 1 : -1);\n        break;\n      default:\n        // If the keyboard event is not handled, return now so that we don't `preventDefault`.\n        return;\n    }\n\n    event.preventDefault();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport interface Entry<FormValue> {\n  value?: FormValue;\n}\n\n/**\n * A convenience class for preserving unsaved form state while an edit lens is closed.\n *\n * Example usage:\n * class MyComponent {\n *   readonly nameEditValues = new FormValueContainer&lt;Item, {name: string}&gt;();\n * }\n *\n * &lt;form cdkEditControl [(cdkEditControlPreservedFormValue)]=\"nameEditValues.for(item).value\"&gt;\n */\nexport class FormValueContainer<Key extends object, FormValue> {\n  private _formValues = new WeakMap<Key, Entry<FormValue>>();\n\n  for(key: Key): Entry<FormValue> {\n    const _formValues = this._formValues;\n\n    let entry = _formValues.get(key);\n    if (!entry) {\n      // Expose entry as an object so that we can [(two-way)] bind to its value member\n      entry = {};\n      _formValues.set(key, entry);\n    }\n\n    return entry;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Subject} from 'rxjs';\nimport {Directive, ElementRef, EventEmitter, OnDestroy, OnInit, Input, inject} from '@angular/core';\nimport {hasModifierKey} from '@angular/cdk/keycodes';\nimport {EDIT_PANE_SELECTOR} from './constants';\nimport {closest} from './polyfill';\nimport {EditRef} from './edit-ref';\n\n/** Options for what do to when the user clicks outside of an edit lens. */\nexport type PopoverEditClickOutBehavior = 'close' | 'submit' | 'noop';\n\n/**\n * A directive that attaches to a form within the edit lens.\n * It coordinates the form state with the table-wide edit system and handles\n * closing the edit lens when the form is submitted or the user clicks\n * out.\n */\n@Directive({\n  selector: 'form[cdkEditControl]',\n  inputs: [\n    {name: 'clickOutBehavior', alias: 'cdkEditControlClickOutBehavior'},\n    {name: 'preservedFormValue', alias: 'cdkEditControlPreservedFormValue'},\n    {name: 'ignoreSubmitUnlessValid', alias: 'cdkEditControlIgnoreSubmitUnlessValid'},\n  ],\n  outputs: ['preservedFormValueChange: cdkEditControlPreservedFormValueChange'],\n  providers: [EditRef],\n  host: {\n    '(ngSubmit)': 'handleFormSubmit()',\n    '(document:click)': 'handlePossibleClickOut($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n})\nexport class CdkEditControl<FormValue> implements OnDestroy, OnInit {\n  protected readonly elementRef = inject(ElementRef);\n  readonly editRef = inject<EditRef<FormValue>>(EditRef);\n\n  protected readonly destroyed = new Subject<void>();\n\n  /**\n   * Specifies what should happen when the user clicks outside of the edit lens.\n   * The default behavior is to close the lens without submitting the form.\n   */\n  clickOutBehavior: PopoverEditClickOutBehavior = 'close';\n\n  /**\n   * A two-way binding for storing unsubmitted form state. If not provided\n   * then form state will be discarded on close. The PeristBy directive is offered\n   * as a convenient shortcut for these bindings.\n   */\n  preservedFormValue?: FormValue;\n  readonly preservedFormValueChange = new EventEmitter<FormValue>();\n\n  /**\n   * Determines whether the lens will close on form submit if the form is not in a valid\n   * state. By default the lens will remain open.\n   */\n  ignoreSubmitUnlessValid = true;\n\n  ngOnInit(): void {\n    this.editRef.init(this.preservedFormValue);\n    this.editRef.finalValue.subscribe(this.preservedFormValueChange);\n    this.editRef.blurred.subscribe(() => this._handleBlur());\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  /**\n   * Called when the form submits. If ignoreSubmitUnlessValid is true, checks\n   * the form for validity before proceeding.\n   * Updates the revert state with the latest submitted value then closes the edit.\n   */\n  handleFormSubmit(): void {\n    if (this.ignoreSubmitUnlessValid && !this.editRef.isValid()) {\n      return;\n    }\n\n    this.editRef.updateRevertValue();\n    this.editRef.close();\n  }\n\n  /** Called on Escape keyup. Closes the edit. */\n  close(): void {\n    // todo - allow this behavior to be customized as well, such as calling\n    // reset before close\n    this.editRef.close();\n  }\n\n  /**\n   * Called on click anywhere in the document.\n   * If the click was outside of the lens, trigger the specified click out behavior.\n   */\n  handlePossibleClickOut(evt: Event): void {\n    if (closest(evt.target, EDIT_PANE_SELECTOR)) {\n      return;\n    }\n    switch (this.clickOutBehavior) {\n      case 'submit':\n        // Manually cause the form to submit before closing.\n        this._triggerFormSubmit();\n        this.editRef.close();\n        break;\n      case 'close':\n        this.editRef.close();\n        break;\n      default:\n        break;\n    }\n  }\n\n  _handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape' && !hasModifierKey(event)) {\n      this.close();\n      event.preventDefault();\n    }\n  }\n\n  /** Triggers submit on tab out if clickOutBehavior is 'submit'. */\n  private _handleBlur(): void {\n    if (this.clickOutBehavior === 'submit') {\n      // Manually cause the form to submit before closing.\n      this._triggerFormSubmit();\n    }\n  }\n\n  private _triggerFormSubmit() {\n    this.elementRef.nativeElement!.dispatchEvent(new Event('submit'));\n  }\n}\n\n/** Reverts the form to its initial or previously submitted state on click. */\n@Directive({\n  selector: 'button[cdkEditRevert]',\n  host: {\n    'type': 'button',\n    '(click)': 'revertEdit()',\n  },\n})\nexport class CdkEditRevert<FormValue> {\n  protected readonly editRef = inject<EditRef<FormValue>>(EditRef);\n\n  /** Type of the button. Defaults to `button` to avoid accident form submits. */\n  @Input() type: string = 'button';\n\n  revertEdit(): void {\n    this.editRef.reset();\n  }\n}\n\n/** Closes the lens on click. */\n@Directive({\n  selector: '[cdkEditClose]',\n  host: {\n    '(click)': 'closeEdit()',\n    '(keydown.enter)': 'closeEdit()',\n    '(keydown.space)': 'closeEdit()',\n  },\n})\nexport class CdkEditClose<FormValue> {\n  protected readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected readonly editRef = inject<EditRef<FormValue>>(EditRef);\n\n  constructor() {\n    const nativeElement = this.elementRef.nativeElement;\n\n    // Prevent accidental form submits.\n    if (nativeElement.nodeName === 'BUTTON' && !nativeElement.getAttribute('type')) {\n      nativeElement.setAttribute('type', 'button');\n    }\n  }\n\n  closeEdit(): void {\n    // Note that we use `click` here, rather than a keyboard event, because some screen readers\n    // will emit a fake click event instead of an enter keyboard event on buttons. For the keyboard\n    // events we use `keydown`, rather than `keyup`, because we use `keydown` to open the overlay\n    // as well. If we were to use `keyup`, the user could end up opening and closing within\n    // the same event sequence if focus was moved quickly.\n    this.editRef.close();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, NgZone, inject} from '@angular/core';\nimport {FocusTrapFactory} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ScrollDispatcher, ViewportRuler} from '@angular/cdk/scrolling';\n\nimport {EditEventDispatcher} from './edit-event-dispatcher';\nimport {FocusDispatcher} from './focus-dispatcher';\nimport {EditRef} from './edit-ref';\n\n/**\n * Optimization\n * Collects multiple Injectables into a singleton shared across the table. By reducing the\n * number of services injected into each CdkPopoverEdit, this saves about 0.023ms of cpu time\n * and 56 bytes of memory per instance.\n */\n@Injectable()\nexport class EditServices {\n  readonly directionality = inject(Directionality);\n  readonly editEventDispatcher = inject<EditEventDispatcher<EditRef<unknown>>>(EditEventDispatcher);\n  readonly focusDispatcher = inject(FocusDispatcher);\n  readonly focusTrapFactory = inject(FocusTrapFactory);\n  readonly ngZone = inject(NgZone);\n  readonly scrollDispatcher = inject(ScrollDispatcher);\n  readonly viewportRuler = inject(ViewportRuler);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, NgZone, inject, DOCUMENT} from '@angular/core';\n\nimport {FocusTrap, InteractivityChecker} from '@angular/cdk/a11y';\nimport {Observable, Subject} from 'rxjs';\n\n/** Value indicating whether focus left the target area before or after the enclosed elements. */\nexport enum FocusEscapeNotifierDirection {\n  START,\n  END,\n}\n\n/**\n * Like FocusTrap, but rather than trapping focus within a dom region, notifies subscribers when\n * focus leaves the region.\n */\nexport class FocusEscapeNotifier extends FocusTrap {\n  private readonly _escapeSubject = new Subject<FocusEscapeNotifierDirection>();\n\n  constructor(\n    element: HTMLElement,\n    checker: InteractivityChecker,\n    ngZone: NgZone,\n    document: Document,\n  ) {\n    super(element, checker, ngZone, document, true /* deferAnchors */);\n\n    // The focus trap adds \"anchors\" at the beginning and end of a trapped region that redirect\n    // focus. We override that redirect behavior here with simply emitting on a stream.\n    this.startAnchorListener = () => {\n      this._escapeSubject.next(FocusEscapeNotifierDirection.START);\n      return true;\n    };\n    this.endAnchorListener = () => {\n      this._escapeSubject.next(FocusEscapeNotifierDirection.END);\n      return true;\n    };\n\n    this.attachAnchors();\n  }\n\n  escapes(): Observable<FocusEscapeNotifierDirection> {\n    return this._escapeSubject;\n  }\n}\n\n/** Factory that allows easy instantiation of focus escape notifiers. */\n@Injectable({providedIn: 'root'})\nexport class FocusEscapeNotifierFactory {\n  private _checker = inject(InteractivityChecker);\n  private _ngZone = inject(NgZone);\n  private _document = inject(DOCUMENT);\n\n  /**\n   * Creates a focus escape notifier region around the given element.\n   * @param element The element around which focus will be monitored.\n   * @returns The created focus escape notifier instance.\n   */\n  create(element: HTMLElement): FocusEscapeNotifier {\n    return new FocusEscapeNotifier(element, this._checker, this._ngZone, this._document);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {FocusTrap} from '@angular/cdk/a11y';\nimport {\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  createRepositionScrollStrategy,\n  OverlayRef,\n  OverlaySizeConfig,\n  PositionStrategy,\n} from '@angular/cdk/overlay';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {\n  afterNextRender,\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EmbeddedViewRef,\n  inject,\n  Injector,\n  ListenerOptions,\n  NgZone,\n  OnDestroy,\n  Renderer2,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {merge, Observable, Subject} from 'rxjs';\nimport {\n  debounceTime,\n  filter,\n  map,\n  mapTo,\n  share,\n  startWith,\n  takeUntil,\n  throttleTime,\n  withLatestFrom,\n} from 'rxjs/operators';\n\nimport {CELL_SELECTOR, EDIT_PANE_CLASS, EDIT_PANE_SELECTOR, ROW_SELECTOR} from './constants';\nimport {EditEventDispatcher, HoverContentState} from './edit-event-dispatcher';\nimport {EditRef} from './edit-ref';\nimport {EditServices} from './edit-services';\nimport {FocusDispatcher} from './focus-dispatcher';\nimport {\n  FocusEscapeNotifier,\n  FocusEscapeNotifierDirection,\n  FocusEscapeNotifierFactory,\n} from './focus-escape-notifier';\nimport {closest} from './polyfill';\n\n/**\n * Describes the number of columns before and after the originating cell that the\n * edit popup should span. In left to right locales, before means left and after means\n * right. In right to left locales before means right and after means left.\n */\nexport interface CdkPopoverEditColspan {\n  before?: number;\n  after?: number;\n}\n\n/** Used for rate-limiting mousemove events. */\nconst MOUSE_MOVE_THROTTLE_TIME_MS = 10;\n\nfunction hasRowElement(nl: NodeList) {\n  for (let i = 0; i < nl.length; i++) {\n    const el = nl[i];\n    if (!(el instanceof HTMLElement)) {\n      continue;\n    }\n    if (el.matches(ROW_SELECTOR)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isRowMutation(mutation: MutationRecord): boolean {\n  return hasRowElement(mutation.addedNodes) || hasRowElement(mutation.removedNodes);\n}\n\n/**\n * A directive that must be attached to enable editability on a table.\n * It is responsible for setting up delegated event handlers and providing the\n * EditEventDispatcher service for use by the other edit directives.\n */\n@Directive({\n  selector: 'table[editable], cdk-table[editable], mat-table[editable]',\n  providers: [EditEventDispatcher, EditServices],\n})\nexport class CdkEditable implements AfterViewInit, OnDestroy {\n  protected readonly elementRef = inject(ElementRef);\n  protected readonly editEventDispatcher =\n    inject<EditEventDispatcher<EditRef<unknown>>>(EditEventDispatcher);\n  protected readonly focusDispatcher = inject(FocusDispatcher);\n  protected readonly ngZone = inject(NgZone);\n  private readonly _renderer = inject(Renderer2);\n\n  protected readonly destroyed = new Subject<void>();\n\n  private _rowsRendered = new Subject();\n\n  private _rowMutationObserver = globalThis.MutationObserver\n    ? new globalThis.MutationObserver(mutations => {\n        if (mutations.some(isRowMutation)) {\n          this._rowsRendered.next();\n        }\n      })\n    : null;\n\n  constructor() {\n    // TODO: consider a design where instead of polling for row changes we just use\n    // afterRenderEffect + a signal of the rows.\n    afterNextRender(() => {\n      this._rowsRendered.next();\n      this._rowMutationObserver?.observe(this.elementRef.nativeElement, {\n        childList: true,\n        subtree: true,\n      });\n    });\n  }\n\n  ngAfterViewInit(): void {\n    this._listenForTableEvents();\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed.next();\n    this.destroyed.complete();\n    this._rowMutationObserver?.disconnect();\n  }\n\n  private _observableFromEvent<T extends Event>(\n    element: Element,\n    name: string,\n    options?: ListenerOptions,\n  ) {\n    return new Observable<T>(subscriber => {\n      const handler = (event: T) => subscriber.next(event);\n      const cleanup = this._renderer.listen(element, name, handler, options);\n      return () => {\n        cleanup();\n        subscriber.complete();\n      };\n    });\n  }\n\n  private _listenForTableEvents(): void {\n    const element = this.elementRef.nativeElement;\n    const toClosest = (selector: string) =>\n      map((event: UIEvent) => closest(event.target, selector));\n\n    this.ngZone.runOutsideAngular(() => {\n      // Track mouse movement over the table to hide/show hover content.\n      this._observableFromEvent<MouseEvent>(element, 'mouseover')\n        .pipe(toClosest(ROW_SELECTOR), takeUntil(this.destroyed))\n        .subscribe(this.editEventDispatcher.hovering);\n      this._observableFromEvent<MouseEvent>(element, 'mouseleave')\n        .pipe(mapTo(null), takeUntil(this.destroyed))\n        .subscribe(this.editEventDispatcher.hovering);\n      this._observableFromEvent<MouseEvent>(element, 'mousemove')\n        .pipe(\n          throttleTime(MOUSE_MOVE_THROTTLE_TIME_MS),\n          toClosest(ROW_SELECTOR),\n          takeUntil(this.destroyed),\n        )\n        .subscribe(this.editEventDispatcher.mouseMove);\n\n      // Track focus within the table to hide/show/make focusable hover content.\n      this._observableFromEvent<FocusEvent>(element, 'focus', {capture: true})\n        .pipe(toClosest(ROW_SELECTOR), share(), takeUntil(this.destroyed))\n        .subscribe(this.editEventDispatcher.focused);\n\n      merge(\n        this._observableFromEvent(element, 'blur', {capture: true}),\n        this._observableFromEvent<KeyboardEvent>(element, 'keydown').pipe(\n          filter(event => event.key === 'Escape'),\n        ),\n      )\n        .pipe(mapTo(null), share(), takeUntil(this.destroyed))\n        .subscribe(this.editEventDispatcher.focused);\n\n      // Keep track of rows within the table. This is used to know which rows with hover content\n      // are first or last in the table. They are kept focusable in case focus enters from above\n      // or below the table.\n      this._rowsRendered\n        .pipe(\n          // Avoid some timing inconsistencies since Angular v19.\n          // TODO: see if we can remove this now that we're using MutationObserver.\n          debounceTime(0),\n          // Optimization: ignore dom changes while focus is within the table as we already\n          // ensure that rows above and below the focused/active row are tabbable.\n          withLatestFrom(this.editEventDispatcher.editingOrFocused),\n          filter(([_, activeRow]) => activeRow == null),\n          map(() => element.querySelectorAll(ROW_SELECTOR)),\n          share(),\n          takeUntil(this.destroyed),\n        )\n        .subscribe(this.editEventDispatcher.allRows);\n\n      this._observableFromEvent<KeyboardEvent>(element, 'keydown')\n        .pipe(\n          filter(event => event.key === 'Enter'),\n          toClosest(CELL_SELECTOR),\n          takeUntil(this.destroyed),\n        )\n        .subscribe(this.editEventDispatcher.editing);\n\n      // Keydown must be used here or else key auto-repeat does not work properly on some platforms.\n      this._observableFromEvent<KeyboardEvent>(element, 'keydown')\n        .pipe(takeUntil(this.destroyed))\n        .subscribe(this.focusDispatcher.keyObserver);\n    });\n  }\n}\n\nconst POPOVER_EDIT_HOST_BINDINGS = {\n  '[attr.tabindex]': 'disabled ? null : 0',\n  'class': 'cdk-popover-edit-cell',\n  '[attr.aria-haspopup]': '!disabled',\n};\n\nconst POPOVER_EDIT_INPUTS = [\n  {name: 'template', alias: 'cdkPopoverEdit'},\n  {name: 'context', alias: 'cdkPopoverEditContext'},\n  {name: 'colspan', alias: 'cdkPopoverEditColspan'},\n  {name: 'disabled', alias: 'cdkPopoverEditDisabled'},\n  {name: 'ariaLabel', alias: 'cdkPopoverEditAriaLabel'},\n];\n\n/**\n * Attaches an ng-template to a cell and shows it when instructed to by the\n * EditEventDispatcher service.\n * Makes the cell focusable.\n */\n@Directive({\n  selector: '[cdkPopoverEdit]:not([cdkPopoverEditTabOut])',\n  host: POPOVER_EDIT_HOST_BINDINGS,\n  inputs: POPOVER_EDIT_INPUTS,\n})\nexport class CdkPopoverEdit<C> implements AfterViewInit, OnDestroy {\n  protected readonly services = inject(EditServices);\n  protected readonly elementRef = inject(ElementRef);\n  protected readonly viewContainerRef = inject(ViewContainerRef);\n  private _injector = inject(Injector);\n\n  /** The edit lens template shown over the cell on edit. */\n  template: TemplateRef<any> | null = null;\n\n  /**\n   * Implicit context to pass along to the template. Can be omitted if the template\n   * is defined within the cell.\n   */\n  context?: C;\n\n  /** Aria label to set on the popover dialog element. */\n  ariaLabel?: string;\n\n  /**\n   * Specifies that the popup should cover additional table cells before and/or after\n   * this one.\n   */\n  get colspan(): CdkPopoverEditColspan {\n    return this._colspan;\n  }\n  set colspan(value: CdkPopoverEditColspan) {\n    this._colspan = value;\n\n    // Recompute positioning when the colspan changes.\n    if (this.overlayRef) {\n      this.overlayRef.updatePositionStrategy(this._getPositionStrategy());\n\n      if (this.overlayRef.hasAttached()) {\n        this._updateOverlaySize();\n      }\n    }\n  }\n  private _colspan: CdkPopoverEditColspan = {};\n\n  /** Whether popover edit is disabled for this cell. */\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n\n    if (value) {\n      this.services.editEventDispatcher.doneEditingCell(this.elementRef.nativeElement!);\n      this.services.editEventDispatcher.disabledCells.set(this.elementRef.nativeElement!, true);\n    } else {\n      this.services.editEventDispatcher.disabledCells.delete(this.elementRef.nativeElement!);\n    }\n  }\n  private _disabled = false;\n\n  protected focusTrap?: FocusTrap;\n  protected overlayRef?: OverlayRef;\n  protected readonly destroyed = new Subject<void>();\n\n  ngAfterViewInit(): void {\n    this._startListeningToEditEvents();\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed.next();\n    this.destroyed.complete();\n\n    if (this.focusTrap) {\n      this.focusTrap.destroy();\n      this.focusTrap = undefined;\n    }\n\n    if (this.overlayRef) {\n      this.overlayRef.dispose();\n    }\n  }\n\n  protected initFocusTrap(): void {\n    this.focusTrap = this.services.focusTrapFactory.create(this.overlayRef!.overlayElement);\n  }\n\n  protected closeEditOverlay(): void {\n    this.services.editEventDispatcher.doneEditingCell(this.elementRef.nativeElement!);\n  }\n\n  protected panelClass(): string {\n    return EDIT_PANE_CLASS;\n  }\n\n  private _startListeningToEditEvents(): void {\n    this.services.editEventDispatcher\n      .editingCell(this.elementRef.nativeElement!)\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(open => {\n        if (open && this.template) {\n          if (!this.overlayRef) {\n            this._createEditOverlay();\n          }\n\n          this._showEditOverlay();\n        } else if (this.overlayRef) {\n          this._maybeReturnFocusToCell();\n\n          this.overlayRef.detach();\n        }\n      });\n  }\n\n  private _createEditOverlay(): void {\n    this.overlayRef = createOverlayRef(this._injector, {\n      disposeOnNavigation: true,\n      panelClass: this.panelClass(),\n      positionStrategy: this._getPositionStrategy(),\n      scrollStrategy: createRepositionScrollStrategy(this._injector),\n      direction: this.services.directionality,\n    });\n\n    this.initFocusTrap();\n    this.overlayRef.overlayElement.setAttribute('role', 'dialog');\n    if (this.ariaLabel) {\n      this.overlayRef.overlayElement.setAttribute('aria-label', this.ariaLabel);\n    }\n\n    this.overlayRef.detachments().subscribe(() => this.closeEditOverlay());\n  }\n\n  private _showEditOverlay(): void {\n    this.overlayRef!.attach(\n      new TemplatePortal(this.template!, this.viewContainerRef, {$implicit: this.context}),\n    );\n\n    // We have to defer trapping focus, because doing so too early can cause the form inside\n    // the overlay to be submitted immediately if it was opened on an Enter keydown event.\n    this.services.ngZone.runOutsideAngular(() => {\n      setTimeout(() => {\n        this.focusTrap!.focusInitialElement();\n      });\n    });\n\n    // Update the size of the popup initially and on subsequent changes to\n    // scroll position and viewport size.\n    merge(this.services.scrollDispatcher.scrolled(), this.services.viewportRuler.change())\n      .pipe(startWith(null), takeUntil(merge(this.overlayRef!.detachments(), this.destroyed)))\n      .subscribe(() => {\n        this._updateOverlaySize();\n      });\n  }\n\n  private _getOverlayCells(): HTMLElement[] {\n    const cell = closest(this.elementRef.nativeElement!, CELL_SELECTOR) as HTMLElement;\n\n    if (!this._colspan.before && !this._colspan.after) {\n      return [cell];\n    }\n\n    const row = closest(this.elementRef.nativeElement!, ROW_SELECTOR)!;\n    const rowCells = Array.from(row.querySelectorAll(CELL_SELECTOR)) as HTMLElement[];\n    const ownIndex = rowCells.indexOf(cell);\n\n    return rowCells.slice(\n      ownIndex - (this._colspan.before || 0),\n      ownIndex + (this._colspan.after || 0) + 1,\n    );\n  }\n\n  private _getPositionStrategy(): PositionStrategy {\n    const cells = this._getOverlayCells();\n    return createFlexibleConnectedPositionStrategy(this._injector, cells[0])\n      .withGrowAfterOpen()\n      .withPush()\n      .withViewportMargin(16)\n      .withPositions([\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n      ]);\n  }\n\n  private _updateOverlaySize(): void {\n    this.overlayRef!.updateSize(this._sizeConfigForCells(this._getOverlayCells()));\n  }\n\n  private _maybeReturnFocusToCell(): void {\n    if (closest(document.activeElement, EDIT_PANE_SELECTOR) === this.overlayRef!.overlayElement) {\n      this.elementRef.nativeElement!.focus();\n    }\n  }\n\n  private _sizeConfigForCells(cells: HTMLElement[]): OverlaySizeConfig {\n    if (cells.length === 0) {\n      return {};\n    }\n\n    if (cells.length === 1) {\n      return {width: cells[0].getBoundingClientRect().width};\n    }\n\n    let firstCell, lastCell;\n    if (this.services.directionality.value === 'ltr') {\n      firstCell = cells[0];\n      lastCell = cells[cells.length - 1];\n    } else {\n      lastCell = cells[0];\n      firstCell = cells[cells.length - 1];\n    }\n\n    return {width: lastCell.getBoundingClientRect().right - firstCell.getBoundingClientRect().left};\n  }\n}\n\n/**\n * Attaches an ng-template to a cell and shows it when instructed to by the\n * EditEventDispatcher service.\n * Makes the cell focusable.\n */\n@Directive({\n  selector: '[cdkPopoverEdit][cdkPopoverEditTabOut]',\n  host: POPOVER_EDIT_HOST_BINDINGS,\n  inputs: POPOVER_EDIT_INPUTS,\n})\nexport class CdkPopoverEditTabOut<C> extends CdkPopoverEdit<C> {\n  protected readonly focusEscapeNotifierFactory = inject(FocusEscapeNotifierFactory);\n\n  protected override focusTrap?: FocusEscapeNotifier = undefined;\n\n  protected override initFocusTrap(): void {\n    this.focusTrap = this.focusEscapeNotifierFactory.create(this.overlayRef!.overlayElement);\n\n    this.focusTrap\n      .escapes()\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(direction => {\n        this.services.editEventDispatcher.editRef?.blur();\n        this.services.focusDispatcher.moveFocusHorizontally(\n          closest(this.elementRef.nativeElement!, CELL_SELECTOR) as HTMLElement,\n          direction === FocusEscapeNotifierDirection.START ? -1 : 1,\n        );\n\n        this.closeEditOverlay();\n      });\n  }\n}\n\n/**\n * A structural directive that shows its contents when the table row containing\n * it is hovered or when an element in the row has focus.\n */\n@Directive({\n  selector: '[cdkRowHoverContent]',\n})\nexport class CdkRowHoverContent implements AfterViewInit, OnDestroy {\n  protected readonly services = inject(EditServices);\n  protected readonly elementRef = inject(ElementRef);\n  protected readonly templateRef = inject<TemplateRef<any>>(TemplateRef);\n  protected readonly viewContainerRef = inject(ViewContainerRef);\n\n  protected readonly destroyed = new Subject<void>();\n  protected viewRef: EmbeddedViewRef<any> | null = null;\n\n  private _row?: Element;\n\n  ngAfterViewInit(): void {\n    this._row = closest(this.elementRef.nativeElement!, ROW_SELECTOR)!;\n\n    this.services.editEventDispatcher.registerRowWithHoverContent(this._row);\n    this._listenForHoverAndFocusEvents();\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed.next();\n    this.destroyed.complete();\n\n    if (this.viewRef) {\n      this.viewRef.destroy();\n    }\n\n    if (this._row) {\n      this.services.editEventDispatcher.deregisterRowWithHoverContent(this._row);\n    }\n  }\n\n  /**\n   * Called immediately after the hover content is created and added to the dom.\n   * In the CDK version, this is a noop but subclasses such as MatRowHoverContent use this\n   * to prepare/style the inserted element.\n   */\n  protected initElement(_: HTMLElement): void {}\n\n  /**\n   * Called when the hover content needs to be focusable to preserve a reasonable tab ordering\n   * but should not yet be shown.\n   */\n  protected makeElementHiddenButFocusable(element: HTMLElement): void {\n    element.style.opacity = '0';\n  }\n\n  /**\n   * Called when the hover content needs to be focusable to preserve a reasonable tab ordering\n   * but should not yet be shown.\n   */\n  protected makeElementVisible(element: HTMLElement): void {\n    element.style.opacity = '';\n  }\n\n  private _listenForHoverAndFocusEvents(): void {\n    this.services.editEventDispatcher\n      .hoverOrFocusOnRow(this._row!)\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(eventState => {\n        // When in FOCUSABLE state, add the hover content to the dom but make it transparent so\n        // that it is in the tab order relative to the currently focused row.\n\n        if (eventState === HoverContentState.ON || eventState === HoverContentState.FOCUSABLE) {\n          if (!this.viewRef) {\n            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, {});\n            this.initElement(this.viewRef.rootNodes[0] as HTMLElement);\n            this.viewRef.markForCheck();\n          } else if (this.viewContainerRef.indexOf(this.viewRef) === -1) {\n            this.viewContainerRef.insert(this.viewRef!);\n            this.viewRef.markForCheck();\n          }\n\n          if (eventState === HoverContentState.ON) {\n            this.makeElementVisible(this.viewRef.rootNodes[0] as HTMLElement);\n          } else {\n            this.makeElementHiddenButFocusable(this.viewRef.rootNodes[0] as HTMLElement);\n          }\n        } else if (this.viewRef) {\n          this.viewContainerRef.detach(this.viewContainerRef.indexOf(this.viewRef));\n        }\n      });\n  }\n}\n\n/**\n * Opens the closest edit popover to this element, whether it's associated with this exact\n * element or an ancestor element.\n */\n@Directive({\n  selector: '[cdkEditOpen]',\n  host: {\n    '(click)': 'openEdit($event)',\n  },\n})\nexport class CdkEditOpen {\n  protected readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected readonly editEventDispatcher =\n    inject<EditEventDispatcher<EditRef<unknown>>>(EditEventDispatcher);\n\n  constructor() {\n    const elementRef = this.elementRef;\n\n    const nativeElement = elementRef.nativeElement;\n\n    // Prevent accidental form submits.\n    if (nativeElement.nodeName === 'BUTTON' && !nativeElement.getAttribute('type')) {\n      nativeElement.setAttribute('type', 'button');\n    }\n  }\n\n  openEdit(evt: Event): void {\n    this.editEventDispatcher.editing.next(closest(this.elementRef.nativeElement!, CELL_SELECTOR));\n    evt.stopPropagation();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {\n  CdkPopoverEdit,\n  CdkPopoverEditTabOut,\n  CdkRowHoverContent,\n  CdkEditable,\n  CdkEditOpen,\n} from './table-directives';\nimport {CdkEditControl, CdkEditRevert, CdkEditClose} from './lens-directives';\n\nconst EXPORTED_DECLARATIONS = [\n  CdkPopoverEdit,\n  CdkPopoverEditTabOut,\n  CdkRowHoverContent,\n  CdkEditControl,\n  CdkEditRevert,\n  CdkEditClose,\n  CdkEditable,\n  CdkEditOpen,\n];\n\n@NgModule({\n  imports: [OverlayModule, ...EXPORTED_DECLARATIONS],\n  exports: EXPORTED_DECLARATIONS,\n})\nexport class CdkPopoverEditModule {}\n"],"names":["TABLE_SELECTOR","EDIT_PANE_CLASS","MOUSE_EVENT_DELAY_MS","FOCUS_DELAY","HoverContentState","EditEventDispatcher","editing","Subject","allRows","_distinctUntilChanged","distinctUntilChanged","pipe","_startWithNull","editingAndEnabled","map","cell","closest","ROW_SELECTOR","focused","editingRow","focusedRow","shareReplay","combineLatest","_getFirstRowWithHoverContent","editingOrFocused","mouseMove","filter","mouseMoveRow","row","debounceTime","_startWithNullDistinct","skip","_enterZone","_lastSeenRow","_lastSeenRowHoverOrFocus","_editingAndEnabledDistinct","subscribe","editingCell","element","doneEditingCell","CELL_SELECTOR","next","unsetActiveEditRef","ref","_editRef","registerRowWithHoverContent","_rowsWithHoverContent","set","get","deregisterRowWithHoverContent","refCount","delete","EditRef","inject","ControlContainer","self","_blurredSubject","blurred","_revertFormValue","_editEventDispatcher","setActiveEditRef","init","previousFormValue","reset","injector","_injector","ngOnDestroy","_finalValueSubject","_form","value","complete","isValid","valid","updateRevertValue","FocusDispatcher","moveFocusHorizontally","currentCell","offset","cells","Array","from","querySelectorAll","EDITABLE_CELL_SELECTOR","currentIndex","indexOf","moveFocusVertically","currentRow","rows","newRowIndex","matches","SKIP_ROW_FOCUS_SELECTOR","rowToFocus","currentIndexWithinRow","focus","entry","clickOutBehavior","preservedFormValueChange","EventEmitter","editRef","preservedFormValue","finalValue","destroyed","handleFormSubmit","close","evt","target","EDIT_PANE_SELECTOR","key","hasModifierKey","event","preventDefault","_handleBlur","_triggerFormSubmit","minVersion","version","ngImport","i0","type","CdkEditControl","decorators","Directive","args","selector","host","ɵfac","ɵɵngDeclareFactory","ɵdir","ɵɵngDeclareDirective","CdkEditRevert","isStandalone","inputs","attributes","listeners","ElementRef","elementRef","nativeElement","getAttribute","setAttribute","closeEdit","ctorParameters","directionality","Directionality","EditServices","deps","ɵɵFactoryTarget","Injectable","FocusEscapeNotifierDirection","FocusEscapeNotifier","FocusTrap","_escapeSubject","constructor","checker","ngZone","document","startAnchorListener","START","endAnchorListener","END","attachAnchors","escapes","FocusEscapeNotifierFactory","_ngZone","NgZone","MOUSE_MOVE_THROTTLE_TIME_MS","hasRowElement","nl","i","length","el","isRowMutation","mutation","addedNodes","removedNodes","CdkEditable","editEventDispatcher","focusDispatcher","_renderer","Renderer2","globalThis","MutationObserver","mutations","some","_rowsRendered","afterNextRender","_rowMutationObserver","observe","ngAfterViewInit","disconnect","_observableFromEvent","name","options","subscriber","_listenForTableEvents","runOutsideAngular","toClosest","takeUntil","mapTo","hovering","throttleTime","capture","share","merge","withLatestFrom","_","activeRow","keyObserver","providers","POPOVER_EDIT_HOST_BINDINGS","alias","CdkPopoverEdit","services","viewContainerRef","ViewContainerRef","Injector","context","colspan","_colspan","overlayRef","updatePositionStrategy","_getPositionStrategy","hasAttached","_updateOverlaySize","disabled","_disabled","disabledCells","focusTrap","_startListeningToEditEvents","destroy","undefined","dispose","focusTrapFactory","create","overlayElement","closeEditOverlay","panelClass","open","template","_createEditOverlay","_showEditOverlay","_maybeReturnFocusToCell","detach","createOverlayRef","disposeOnNavigation","positionStrategy","scrollStrategy","createRepositionScrollStrategy","ariaLabel","detachments","attach","TemplatePortal","$implicit","setTimeout","focusInitialElement","scrollDispatcher","scrolled","viewportRuler","change","startWith","_getOverlayCells","before","after","rowCells","slice","ownIndex","withPush","withViewportMargin","withPositions","originX","overlayX","updateSize","_sizeConfigForCells","activeElement","width","getBoundingClientRect","firstCell","lastCell","left","properties","classAttribute","POPOVER_EDIT_INPUTS","focusEscapeNotifierFactory","initFocusTrap","usesInheritance","CdkPopoverEditModule","NgModule","ɵmod","ɵɵngDeclareNgModule","imports","OverlayModule","EXPORTED_DECLARATIONS"],"mappings":"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"}