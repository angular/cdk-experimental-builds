{"version":3,"file":"scrolling.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/scrolling/auto-size-virtual-scroll.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk-experimental/scrolling/scrolling-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {coerceNumberProperty, NumberInput} from '@angular/cdk/coercion';\nimport {ListRange} from '@angular/cdk/collections';\nimport {\n  CdkVirtualScrollViewport,\n  VIRTUAL_SCROLL_STRATEGY,\n  VirtualScrollStrategy,\n} from '@angular/cdk/scrolling';\nimport {Directive, forwardRef, Input, OnChanges} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nexport class ItemSizeAverager {\n  /** The total amount of weight behind the current average. */\n  private _totalWeight = 0;\n\n  /** The current average item size. */\n  private _averageItemSize: number;\n\n  /** The default size to use for items when no data is available. */\n  private _defaultItemSize: number;\n\n  /** @param defaultItemSize The default size to use for items when no data is available. */\n  constructor(defaultItemSize = 50) {\n    this._defaultItemSize = defaultItemSize;\n    this._averageItemSize = defaultItemSize;\n  }\n\n  /** Returns the average item size. */\n  getAverageItemSize(): number {\n    return this._averageItemSize;\n  }\n\n  /**\n   * Adds a measurement sample for the estimator to consider.\n   * @param range The measured range.\n   * @param size The measured size of the given range in pixels.\n   */\n  addSample(range: ListRange, size: number) {\n    const newTotalWeight = this._totalWeight + range.end - range.start;\n    if (newTotalWeight) {\n      const newAverageItemSize =\n        (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n      if (newAverageItemSize) {\n        this._averageItemSize = newAverageItemSize;\n        this._totalWeight = newTotalWeight;\n      }\n    }\n  }\n\n  /** Resets the averager. */\n  reset() {\n    this._averageItemSize = this._defaultItemSize;\n    this._totalWeight = 0;\n  }\n}\n\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nexport class AutoSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  scrolledIndexChange = new Observable<number>(() => {\n    // TODO(mmalerba): Implement.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error(\n        'cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n          ' autosize scroll strategy',\n      );\n    }\n  });\n\n  /** The attached viewport. */\n  private _viewport: CdkVirtualScrollViewport | null = null;\n\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n  private _minBufferPx: number;\n\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n  private _maxBufferPx: number;\n\n  /** The estimator used to estimate the size of unseen items. */\n  private _averager: ItemSizeAverager;\n\n  /** The last measured scroll offset of the viewport. */\n  private _lastScrollOffset: number;\n\n  /** The last measured size of the rendered content in the viewport. */\n  private _lastRenderedContentSize: number;\n\n  /** The last measured size of the rendered content in the viewport. */\n  private _lastRenderedContentOffset: number;\n\n  /**\n   * The number of consecutive cycles where removing extra items has failed. Failure here means that\n   * we estimated how many items we could safely remove, but our estimate turned out to be too much\n   * and it wasn't safe to remove that many elements.\n   */\n  private _removalFailures = 0;\n\n  /**\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   *     If the amount of buffer dips below this number, more items will be rendered.\n   * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n   *     If the actual amount turns out to be less it will not necessarily trigger an additional\n   *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * @param averager The averager used to estimate the size of unseen items.\n   */\n  constructor(minBufferPx: number, maxBufferPx: number, averager = new ItemSizeAverager()) {\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._averager = averager;\n  }\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport) {\n    this._averager.reset();\n    this._viewport = viewport;\n    this._renderContentForCurrentOffset();\n  }\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._viewport = null;\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    if (this._viewport) {\n      this._updateRenderedContentAfterScroll();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    if (this._viewport) {\n      this._renderContentForCurrentOffset();\n      this._checkRenderedContentSize();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() {\n    if (this._viewport) {\n      this._checkRenderedContentSize();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() {\n    if (this._viewport) {\n      this._checkRenderedContentOffset();\n    }\n  }\n\n  /** Scroll to the offset for the given index. */\n  scrollToIndex(): void {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      // TODO(mmalerba): Implement.\n      throw Error(\n        'cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize' +\n          ' scroll strategy',\n      );\n    }\n  }\n\n  /**\n   * Update the buffer parameters.\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n   *     pixels).\n   */\n  updateBufferSize(minBufferPx: number, maxBufferPx: number) {\n    if (maxBufferPx < minBufferPx) {\n      throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n\n  /** Update the rendered content after the user scrolls. */\n  private _updateRenderedContentAfterScroll() {\n    const viewport = this._viewport!;\n\n    // The current scroll offset.\n    const scrollOffset = viewport.measureScrollOffset();\n    // The delta between the current scroll offset and the previously recorded scroll offset.\n    let scrollDelta = scrollOffset - this._lastScrollOffset;\n    // The magnitude of the scroll delta.\n    let scrollMagnitude = Math.abs(scrollDelta);\n\n    // The currently rendered range.\n    const renderedRange = viewport.getRenderedRange();\n\n    // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n    // of content and the actual amount of scrollable space may differ. We address this by slowly\n    // correcting the difference on each scroll event.\n    let offsetCorrection = 0;\n    if (scrollDelta < 0) {\n      // The content offset we would expect based on the average item size.\n      const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n      // The difference between the predicted size of the un-rendered content at the beginning and\n      // the actual available space to scroll over. We need to reduce this to zero by the time the\n      // user scrolls to the top.\n      // - 0 indicates that the predicted size and available space are the same.\n      // - A negative number that the predicted size is smaller than the available space.\n      // - A positive number indicates the predicted size is larger than the available space\n      const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n      // The amount of difference to correct during this scroll event. We calculate this as a\n      // percentage of the total difference based on the percentage of the distance toward the top\n      // that the user scrolled.\n      offsetCorrection = Math.round(\n        offsetDifference *\n          Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))),\n      );\n\n      // Based on the offset correction above, we pretend that the scroll delta was bigger or\n      // smaller than it actually was, this way we can start to eliminate the difference.\n      scrollDelta = scrollDelta - offsetCorrection;\n      scrollMagnitude = Math.abs(scrollDelta);\n    }\n\n    // The current amount of buffer past the start of the viewport.\n    const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n    // The current amount of buffer past the end of the viewport.\n    const endBuffer =\n      this._lastRenderedContentOffset +\n      this._lastRenderedContentSize -\n      (this._lastScrollOffset + viewport.getViewportSize());\n    // The amount of unfilled space that should be filled on the side the user is scrolling toward\n    // in order to safely absorb the scroll delta.\n    const underscan =\n      scrollMagnitude + this._minBufferPx - (scrollDelta < 0 ? startBuffer : endBuffer);\n\n    // Check if there's unfilled space that we need to render new elements to fill.\n    if (underscan > 0) {\n      // Check if the scroll magnitude was larger than the viewport size. In this case the user\n      // won't notice a discontinuity if we just jump to the new estimated position in the list.\n      // However, if the scroll magnitude is smaller than the viewport the user might notice some\n      // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n      // the same number of pixels as the scroll magnitude.\n      if (scrollMagnitude >= viewport.getViewportSize()) {\n        this._renderContentForCurrentOffset();\n      } else {\n        // The number of new items to render on the side the user is scrolling towards. Rather than\n        // just filling the underscan space, we actually fill enough to have a buffer size of\n        // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n        const addItems = Math.max(\n          0,\n          Math.ceil(\n            (underscan - this._minBufferPx + this._maxBufferPx) /\n              this._averager.getAverageItemSize(),\n          ),\n        );\n        // The amount of filled space beyond what is necessary on the side the user is scrolling\n        // away from.\n        const overscan =\n          (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx + scrollMagnitude;\n        // The number of currently rendered items to remove on the side the user is scrolling away\n        // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n        // remove.\n        const unboundedRemoveItems = Math.floor(\n          overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1),\n        );\n        const removeItems = Math.min(\n          renderedRange.end - renderedRange.start,\n          Math.max(0, unboundedRemoveItems),\n        );\n\n        // The new range we will tell the viewport to render. We first expand it to include the new\n        // items we want rendered, we then contract the opposite side to remove items we no longer\n        // want rendered.\n        const range = this._expandRange(\n          renderedRange,\n          scrollDelta < 0 ? addItems : 0,\n          scrollDelta > 0 ? addItems : 0,\n        );\n        if (scrollDelta < 0) {\n          range.end = Math.max(range.start + 1, range.end - removeItems);\n        } else {\n          range.start = Math.min(range.end - 1, range.start + removeItems);\n        }\n\n        // The new offset we want to set on the rendered content. To determine this we measure the\n        // number of pixels we removed and then adjust the offset to the start of the rendered\n        // content or to the end of the rendered content accordingly (whichever one doesn't require\n        // that the newly added items to be rendered to calculate.)\n        let contentOffset: number;\n        let contentOffsetTo: 'to-start' | 'to-end';\n        if (scrollDelta < 0) {\n          let removedSize = viewport.measureRangeSize({\n            start: range.end,\n            end: renderedRange.end,\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset =\n              this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.end = renderedRange.end;\n            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-end';\n        } else {\n          const removedSize = viewport.measureRangeSize({\n            start: renderedRange.start,\n            end: range.start,\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset = this._lastRenderedContentOffset + removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.start = renderedRange.start;\n            contentOffset = this._lastRenderedContentOffset;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-start';\n        }\n\n        // Set the range and offset we calculated above.\n        viewport.setRenderedRange(range);\n        viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n      }\n    } else if (offsetCorrection) {\n      // Even if the rendered range didn't change, we may still need to adjust the content offset to\n      // simulate scrolling slightly slower or faster than the user actually scrolled.\n      viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n    }\n\n    // Save the scroll offset to be compared to the new value on the next scroll event.\n    this._lastScrollOffset = scrollOffset;\n  }\n\n  /**\n   * Checks the size of the currently rendered content and uses it to update the estimated item size\n   * and estimated total content size.\n   */\n  private _checkRenderedContentSize() {\n    const viewport = this._viewport!;\n    this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n    this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n    this._updateTotalContentSize(this._lastRenderedContentSize);\n  }\n\n  /** Checks the currently rendered content offset and saves the value for later use. */\n  private _checkRenderedContentOffset() {\n    const viewport = this._viewport!;\n    this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart()!;\n  }\n\n  /**\n   * Recalculates the rendered content based on our estimate of what should be shown at the current\n   * scroll offset.\n   */\n  private _renderContentForCurrentOffset() {\n    const viewport = this._viewport!;\n    const scrollOffset = viewport.measureScrollOffset();\n    this._lastScrollOffset = scrollOffset;\n    this._removalFailures = 0;\n\n    const itemSize = this._averager.getAverageItemSize();\n    const firstVisibleIndex = Math.min(\n      viewport.getDataLength() - 1,\n      Math.floor(scrollOffset / itemSize),\n    );\n    const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n    const range = this._expandRange(\n      this._getVisibleRangeForIndex(firstVisibleIndex),\n      bufferSize,\n      bufferSize,\n    );\n\n    viewport.setRenderedRange(range);\n    viewport.setRenderedContentOffset(itemSize * range.start);\n  }\n\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Gets the visible range of data for the given start index. If the start index is too close to\n   * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n   * fill the viewport.\n   * Note: must not be called if `this._viewport` is null\n   * @param startIndex The index to start the range at\n   * @return a range estimated to be large enough to fill the viewport when rendered.\n   */\n  private _getVisibleRangeForIndex(startIndex: number): ListRange {\n    const viewport = this._viewport!;\n    const range: ListRange = {\n      start: startIndex,\n      end: startIndex + Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize()),\n    };\n    const extra = range.end - viewport.getDataLength();\n    if (extra > 0) {\n      range.start = Math.max(0, range.start - extra);\n    }\n    return range;\n  }\n\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Expand the given range by the given amount in either direction.\n   * Note: must not be called if `this._viewport` is null\n   * @param range The range to expand\n   * @param expandStart The number of items to expand the start of the range by.\n   * @param expandEnd The number of items to expand the end of the range by.\n   * @return The expanded range.\n   */\n  private _expandRange(range: ListRange, expandStart: number, expandEnd: number): ListRange {\n    const viewport = this._viewport!;\n    const start = Math.max(0, range.start - expandStart);\n    const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n    return {start, end};\n  }\n\n  /** Update the viewport's total content size. */\n  private _updateTotalContentSize(renderedContentSize: number) {\n    const viewport = this._viewport!;\n    const renderedRange = viewport.getRenderedRange();\n    const totalSize =\n      renderedContentSize +\n      (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n        this._averager.getAverageItemSize();\n    viewport.setTotalContentSize(totalSize);\n  }\n}\n\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nexport function _autoSizeVirtualScrollStrategyFactory(autoSizeDir: CdkAutoSizeVirtualScroll) {\n  return autoSizeDir._scrollStrategy;\n}\n\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\n@Directive({\n  selector: 'cdk-virtual-scroll-viewport[autosize]',\n  providers: [\n    {\n      provide: VIRTUAL_SCROLL_STRATEGY,\n      useFactory: _autoSizeVirtualScrollStrategyFactory,\n      deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n    },\n  ],\n})\nexport class CdkAutoSizeVirtualScroll implements OnChanges {\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  @Input()\n  get minBufferPx(): number {\n    return this._minBufferPx;\n  }\n  set minBufferPx(value: NumberInput) {\n    this._minBufferPx = coerceNumberProperty(value);\n  }\n  _minBufferPx = 100;\n\n  /**\n   * The number of pixels worth of buffer to shoot for when rendering new items.\n   * If the actual amount turns out to be less it will not necessarily trigger an additional\n   * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * Defaults to 200px.\n   */\n  @Input()\n  get maxBufferPx(): number {\n    return this._maxBufferPx;\n  }\n  set maxBufferPx(value: NumberInput) {\n    this._maxBufferPx = coerceNumberProperty(value);\n  }\n  _maxBufferPx = 200;\n\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n\n  ngOnChanges() {\n    this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutoSizeVirtualScroll} from './auto-size-virtual-scroll';\n\n@NgModule({\n  imports: [CdkAutoSizeVirtualScroll],\n  exports: [CdkAutoSizeVirtualScroll],\n})\nexport class ScrollingModule {}\n"],"names":["ItemSizeAverager","_totalWeight","_averageItemSize","_defaultItemSize","constructor","defaultItemSize","getAverageItemSize","addSample","range","size","newTotalWeight","end","start","newAverageItemSize","reset","AutoSizeVirtualScrollStrategy","scrolledIndexChange","Observable","ngDevMode","Error","_viewport","_minBufferPx","_maxBufferPx","_averager","_lastScrollOffset","_lastRenderedContentSize","_lastRenderedContentOffset","_removalFailures","minBufferPx","maxBufferPx","averager","attach","viewport","_renderContentForCurrentOffset","detach","onContentScrolled","_updateRenderedContentAfterScroll","onDataLengthChanged","_checkRenderedContentSize","onContentRendered","onRenderedOffsetChanged","_checkRenderedContentOffset","scrollToIndex","updateBufferSize","scrollOffset","measureScrollOffset","scrollDelta","scrollMagnitude","Math","abs","renderedRange","getRenderedRange","offsetCorrection","predictedOffset","offsetDifference","round","max","min","startBuffer","endBuffer","getViewportSize","underscan","addItems","ceil","overscan","unboundedRemoveItems","floor","removeItems","_expandRange","contentOffset","contentOffsetTo","removedSize","measureRangeSize","setRenderedRange","setRenderedContentOffset","measureRenderedContentSize","_updateTotalContentSize","getOffsetToRenderedContentStart","itemSize","firstVisibleIndex","getDataLength","bufferSize","_getVisibleRangeForIndex","startIndex","extra","expandStart","expandEnd","renderedContentSize","totalSize","setTotalContentSize","_autoSizeVirtualScrollStrategyFactory","autoSizeDir","_scrollStrategy","CdkAutoSizeVirtualScroll","value","coerceNumberProperty","ngOnChanges","deps","target","i0","ɵɵFactoryTarget","Directive","ɵdir","ɵɵngDeclareDirective","minVersion","version","type","isStandalone","selector","inputs","providers","provide","VIRTUAL_SCROLL_STRATEGY","useFactory","forwardRef","usesOnChanges","ngImport","decorators","args","Input","ScrollingModule","NgModule","imports","exports"],"mappings":"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"}