{"version":3,"sources":["src/cdk-experimental/cdk-experimental-scrolling.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","cdkExperimental","scrolling","cdk","coercion","core","rxjs","this","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","ItemSizeAverager","defaultItemSize","_totalWeight","_defaultItemSize","_averageItemSize","prototype","getAverageItemSize","addSample","range","size","newTotalWeight","end","start","newAverageItemSize","reset","AutoSizeVirtualScrollStrategy","minBufferPx","maxBufferPx","averager","scrolledIndexChange","Observable","Error","_viewport","_removalFailures","_minBufferPx","_maxBufferPx","_averager","attach","viewport","_renderContentForCurrentOffset","detach","onContentScrolled","_updateRenderedContentAfterScroll","onDataLengthChanged","_checkRenderedContentSize","onContentRendered","onRenderedOffsetChanged","_checkRenderedContentOffset","scrollToIndex","updateBufferSize","scrollOffset","measureScrollOffset","scrollDelta","_lastScrollOffset","scrollMagnitude","Math","abs","renderedRange","getRenderedRange","offsetCorrection","predictedOffset","round","_lastRenderedContentOffset","max","min","startBuffer","endBuffer","_lastRenderedContentSize","getViewportSize","underscan","addItems","ceil","overscan","unboundedRemoveItems","floor","removeItems","_expandRange","removedSize","contentOffset","contentOffsetTo","measureRangeSize","setRenderedRange","setRenderedContentOffset","measureRenderedContentSize","_updateTotalContentSize","getOffsetToRenderedContentStart","itemSize","firstVisibleIndex","getDataLength","bufferSize","_getVisibleRangeForIndex","startIndex","extra","expandStart","expandEnd","renderedContentSize","totalSize","setTotalContentSize","_autoSizeVirtualScrollStrategyFactory","autoSizeDir","_scrollStrategy","CdkAutoSizeVirtualScroll","CdkAutoSizeVirtualScroll_1","get","set","value","coerceNumberProperty","enumerable","configurable","ngOnChanges","Input","Number","Directive","selector","providers","provide","VIRTUAL_SCROLL_STRATEGY","useFactory","deps","forwardRef","ScrollingModule","NgModule","declarations"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/coercion'), require('@angular/cdk/scrolling'), require('@angular/core'), require('rxjs')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk-experimental/scrolling', ['exports', '@angular/cdk/coercion', '@angular/cdk/scrolling', '@angular/core', 'rxjs'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdkExperimental = global.ng.cdkExperimental || {}, global.ng.cdkExperimental.scrolling = {}), global.ng.cdk.coercion, global.ng.cdk.scrolling, global.ng.core, global.rxjs));\n}(this, (function (exports, coercion, scrolling, core, rxjs) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n    }\r\n\r\n    function __values(o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\r\n\r\n    function __classPrivateFieldGet(receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    }\r\n\r\n    function __classPrivateFieldSet(receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A class that tracks the size of items that have been seen and uses it to estimate the average\n     * item size.\n     */\n    var ItemSizeAverager = /** @class */ (function () {\n        /** @param defaultItemSize The default size to use for items when no data is available. */\n        function ItemSizeAverager(defaultItemSize) {\n            if (defaultItemSize === void 0) { defaultItemSize = 50; }\n            /** The total amount of weight behind the current average. */\n            this._totalWeight = 0;\n            this._defaultItemSize = defaultItemSize;\n            this._averageItemSize = defaultItemSize;\n        }\n        /** Returns the average item size. */\n        ItemSizeAverager.prototype.getAverageItemSize = function () {\n            return this._averageItemSize;\n        };\n        /**\n         * Adds a measurement sample for the estimator to consider.\n         * @param range The measured range.\n         * @param size The measured size of the given range in pixels.\n         */\n        ItemSizeAverager.prototype.addSample = function (range, size) {\n            var newTotalWeight = this._totalWeight + range.end - range.start;\n            if (newTotalWeight) {\n                var newAverageItemSize = (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n                if (newAverageItemSize) {\n                    this._averageItemSize = newAverageItemSize;\n                    this._totalWeight = newTotalWeight;\n                }\n            }\n        };\n        /** Resets the averager. */\n        ItemSizeAverager.prototype.reset = function () {\n            this._averageItemSize = this._defaultItemSize;\n            this._totalWeight = 0;\n        };\n        return ItemSizeAverager;\n    }());\n    /** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\n    var AutoSizeVirtualScrollStrategy = /** @class */ (function () {\n        /**\n         * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n         *     If the amount of buffer dips below this number, more items will be rendered.\n         * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n         *     If the actual amount turns out to be less it will not necessarily trigger an additional\n         *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n         * @param averager The averager used to estimate the size of unseen items.\n         */\n        function AutoSizeVirtualScrollStrategy(minBufferPx, maxBufferPx, averager) {\n            if (averager === void 0) { averager = new ItemSizeAverager(); }\n            /** @docs-private Implemented as part of VirtualScrollStrategy. */\n            this.scrolledIndexChange = new rxjs.Observable(function () {\n                // TODO(mmalerba): Implement.\n                throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n                    ' autosize scroll strategy');\n            });\n            /** The attached viewport. */\n            this._viewport = null;\n            /**\n             * The number of consecutive cycles where removing extra items has failed. Failure here means that\n             * we estimated how many items we could safely remove, but our estimate turned out to be too much\n             * and it wasn't safe to remove that many elements.\n             */\n            this._removalFailures = 0;\n            this._minBufferPx = minBufferPx;\n            this._maxBufferPx = maxBufferPx;\n            this._averager = averager;\n        }\n        /**\n         * Attaches this scroll strategy to a viewport.\n         * @param viewport The viewport to attach this strategy to.\n         */\n        AutoSizeVirtualScrollStrategy.prototype.attach = function (viewport) {\n            this._averager.reset();\n            this._viewport = viewport;\n            this._renderContentForCurrentOffset();\n        };\n        /** Detaches this scroll strategy from the currently attached viewport. */\n        AutoSizeVirtualScrollStrategy.prototype.detach = function () {\n            this._viewport = null;\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onContentScrolled = function () {\n            if (this._viewport) {\n                this._updateRenderedContentAfterScroll();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onDataLengthChanged = function () {\n            if (this._viewport) {\n                this._renderContentForCurrentOffset();\n                this._checkRenderedContentSize();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onContentRendered = function () {\n            if (this._viewport) {\n                this._checkRenderedContentSize();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onRenderedOffsetChanged = function () {\n            if (this._viewport) {\n                this._checkRenderedContentOffset();\n            }\n        };\n        /** Scroll to the offset for the given index. */\n        AutoSizeVirtualScrollStrategy.prototype.scrollToIndex = function () {\n            // TODO(mmalerba): Implement.\n            throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize'\n                + ' scroll strategy');\n        };\n        /**\n         * Update the buffer parameters.\n         * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n         * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n         *     pixels).\n         */\n        AutoSizeVirtualScrollStrategy.prototype.updateBufferSize = function (minBufferPx, maxBufferPx) {\n            if (maxBufferPx < minBufferPx) {\n                throw ('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n            }\n            this._minBufferPx = minBufferPx;\n            this._maxBufferPx = maxBufferPx;\n        };\n        /** Update the rendered content after the user scrolls. */\n        AutoSizeVirtualScrollStrategy.prototype._updateRenderedContentAfterScroll = function () {\n            var viewport = this._viewport;\n            // The current scroll offset.\n            var scrollOffset = viewport.measureScrollOffset();\n            // The delta between the current scroll offset and the previously recorded scroll offset.\n            var scrollDelta = scrollOffset - this._lastScrollOffset;\n            // The magnitude of the scroll delta.\n            var scrollMagnitude = Math.abs(scrollDelta);\n            // The currently rendered range.\n            var renderedRange = viewport.getRenderedRange();\n            // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n            // of content and the actual amount of scrollable space may differ. We address this by slowly\n            // correcting the difference on each scroll event.\n            var offsetCorrection = 0;\n            if (scrollDelta < 0) {\n                // The content offset we would expect based on the average item size.\n                var predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n                // The difference between the predicted size of the unrendered content at the beginning and\n                // the actual available space to scroll over. We need to reduce this to zero by the time the\n                // user scrolls to the top.\n                // - 0 indicates that the predicted size and available space are the same.\n                // - A negative number that the predicted size is smaller than the available space.\n                // - A positive number indicates the predicted size is larger than the available space\n                var offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n                // The amount of difference to correct during this scroll event. We calculate this as a\n                // percentage of the total difference based on the percentage of the distance toward the top\n                // that the user scrolled.\n                offsetCorrection = Math.round(offsetDifference *\n                    Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n                // Based on the offset correction above, we pretend that the scroll delta was bigger or\n                // smaller than it actually was, this way we can start to eliminate the difference.\n                scrollDelta = scrollDelta - offsetCorrection;\n                scrollMagnitude = Math.abs(scrollDelta);\n            }\n            // The current amount of buffer past the start of the viewport.\n            var startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n            // The current amount of buffer past the end of the viewport.\n            var endBuffer = (this._lastRenderedContentOffset + this._lastRenderedContentSize) -\n                (this._lastScrollOffset + viewport.getViewportSize());\n            // The amount of unfilled space that should be filled on the side the user is scrolling toward\n            // in order to safely absorb the scroll delta.\n            var underscan = scrollMagnitude + this._minBufferPx -\n                (scrollDelta < 0 ? startBuffer : endBuffer);\n            // Check if there's unfilled space that we need to render new elements to fill.\n            if (underscan > 0) {\n                // Check if the scroll magnitude was larger than the viewport size. In this case the user\n                // won't notice a discontinuity if we just jump to the new estimated position in the list.\n                // However, if the scroll magnitude is smaller than the viewport the user might notice some\n                // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n                // the same number of pixels as the scroll magnitude.\n                if (scrollMagnitude >= viewport.getViewportSize()) {\n                    this._renderContentForCurrentOffset();\n                }\n                else {\n                    // The number of new items to render on the side the user is scrolling towards. Rather than\n                    // just filling the underscan space, we actually fill enough to have a buffer size of\n                    // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n                    var addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\n                        this._averager.getAverageItemSize()));\n                    // The amount of filled space beyond what is necessary on the side the user is scrolling\n                    // away from.\n                    var overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx +\n                        scrollMagnitude;\n                    // The number of currently rendered items to remove on the side the user is scrolling away\n                    // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n                    // remove.\n                    var unboundedRemoveItems = Math.floor(overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n                    var removeItems = Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n                    // The new range we will tell the viewport to render. We first expand it to include the new\n                    // items we want rendered, we then contract the opposite side to remove items we no longer\n                    // want rendered.\n                    var range = this._expandRange(renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n                    if (scrollDelta < 0) {\n                        range.end = Math.max(range.start + 1, range.end - removeItems);\n                    }\n                    else {\n                        range.start = Math.min(range.end - 1, range.start + removeItems);\n                    }\n                    // The new offset we want to set on the rendered content. To determine this we measure the\n                    // number of pixels we removed and then adjust the offset to the start of the rendered\n                    // content or to the end of the rendered content accordingly (whichever one doesn't require\n                    // that the newly added items to be rendered to calculate.)\n                    var contentOffset = void 0;\n                    var contentOffsetTo = void 0;\n                    if (scrollDelta < 0) {\n                        var removedSize = viewport.measureRangeSize({\n                            start: range.end,\n                            end: renderedRange.end,\n                        });\n                        // Check that we're not removing too much.\n                        if (removedSize <= overscan) {\n                            contentOffset =\n                                this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n                            this._removalFailures = 0;\n                        }\n                        else {\n                            // If the removal is more than the overscan can absorb just undo it and record the fact\n                            // that the removal failed so we can be less aggressive next time.\n                            range.end = renderedRange.end;\n                            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n                            this._removalFailures++;\n                        }\n                        contentOffsetTo = 'to-end';\n                    }\n                    else {\n                        var removedSize = viewport.measureRangeSize({\n                            start: renderedRange.start,\n                            end: range.start,\n                        });\n                        // Check that we're not removing too much.\n                        if (removedSize <= overscan) {\n                            contentOffset = this._lastRenderedContentOffset + removedSize;\n                            this._removalFailures = 0;\n                        }\n                        else {\n                            // If the removal is more than the overscan can absorb just undo it and record the fact\n                            // that the removal failed so we can be less aggressive next time.\n                            range.start = renderedRange.start;\n                            contentOffset = this._lastRenderedContentOffset;\n                            this._removalFailures++;\n                        }\n                        contentOffsetTo = 'to-start';\n                    }\n                    // Set the range and offset we calculated above.\n                    viewport.setRenderedRange(range);\n                    viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n                }\n            }\n            else if (offsetCorrection) {\n                // Even if the rendered range didn't change, we may still need to adjust the content offset to\n                // simulate scrolling slightly slower or faster than the user actually scrolled.\n                viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n            }\n            // Save the scroll offset to be compared to the new value on the next scroll event.\n            this._lastScrollOffset = scrollOffset;\n        };\n        /**\n         * Checks the size of the currently rendered content and uses it to update the estimated item size\n         * and estimated total content size.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._checkRenderedContentSize = function () {\n            var viewport = this._viewport;\n            this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n            this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n            this._updateTotalContentSize(this._lastRenderedContentSize);\n        };\n        /** Checks the currently rendered content offset and saves the value for later use. */\n        AutoSizeVirtualScrollStrategy.prototype._checkRenderedContentOffset = function () {\n            var viewport = this._viewport;\n            this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart();\n        };\n        /**\n         * Recalculates the rendered content based on our estimate of what should be shown at the current\n         * scroll offset.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._renderContentForCurrentOffset = function () {\n            var viewport = this._viewport;\n            var scrollOffset = viewport.measureScrollOffset();\n            this._lastScrollOffset = scrollOffset;\n            this._removalFailures = 0;\n            var itemSize = this._averager.getAverageItemSize();\n            var firstVisibleIndex = Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n            var bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n            var range = this._expandRange(this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n            viewport.setRenderedRange(range);\n            viewport.setRenderedContentOffset(itemSize * range.start);\n        };\n        // TODO: maybe move to base class, can probably share with fixed size strategy.\n        /**\n         * Gets the visible range of data for the given start index. If the start index is too close to\n         * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n         * fill the viewport.\n         * Note: must not be called if `this._viewport` is null\n         * @param startIndex The index to start the range at\n         * @return a range estimated to be large enough to fill the viewport when rendered.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._getVisibleRangeForIndex = function (startIndex) {\n            var viewport = this._viewport;\n            var range = {\n                start: startIndex,\n                end: startIndex +\n                    Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize())\n            };\n            var extra = range.end - viewport.getDataLength();\n            if (extra > 0) {\n                range.start = Math.max(0, range.start - extra);\n            }\n            return range;\n        };\n        // TODO: maybe move to base class, can probably share with fixed size strategy.\n        /**\n         * Expand the given range by the given amount in either direction.\n         * Note: must not be called if `this._viewport` is null\n         * @param range The range to expand\n         * @param expandStart The number of items to expand the start of the range by.\n         * @param expandEnd The number of items to expand the end of the range by.\n         * @return The expanded range.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._expandRange = function (range, expandStart, expandEnd) {\n            var viewport = this._viewport;\n            var start = Math.max(0, range.start - expandStart);\n            var end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n            return { start: start, end: end };\n        };\n        /** Update the viewport's total content size. */\n        AutoSizeVirtualScrollStrategy.prototype._updateTotalContentSize = function (renderedContentSize) {\n            var viewport = this._viewport;\n            var renderedRange = viewport.getRenderedRange();\n            var totalSize = renderedContentSize +\n                (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n                    this._averager.getAverageItemSize();\n            viewport.setTotalContentSize(totalSize);\n        };\n        return AutoSizeVirtualScrollStrategy;\n    }());\n    /**\n     * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n     * `AutoSizeVirtualScrollStrategy` from the given directive.\n     * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n     *     `AutoSizeVirtualScrollStrategy` from.\n     */\n    function _autoSizeVirtualScrollStrategyFactory(autoSizeDir) {\n        return autoSizeDir._scrollStrategy;\n    }\n    /** A virtual scroll strategy that supports unknown or dynamic size items. */\n    var CdkAutoSizeVirtualScroll = /** @class */ (function () {\n        function CdkAutoSizeVirtualScroll() {\n            this._minBufferPx = 100;\n            this._maxBufferPx = 200;\n            /** The scroll strategy used by this directive. */\n            this._scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n        }\n        CdkAutoSizeVirtualScroll_1 = CdkAutoSizeVirtualScroll;\n        Object.defineProperty(CdkAutoSizeVirtualScroll.prototype, \"minBufferPx\", {\n            /**\n             * The minimum amount of buffer rendered beyond the viewport (in pixels).\n             * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n             */\n            get: function () { return this._minBufferPx; },\n            set: function (value) { this._minBufferPx = coercion.coerceNumberProperty(value); },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(CdkAutoSizeVirtualScroll.prototype, \"maxBufferPx\", {\n            /**\n             * The number of pixels worth of buffer to shoot for when rendering new items.\n             * If the actual amount turns out to be less it will not necessarily trigger an additional\n             * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n             * Defaults to 200px.\n             */\n            get: function () { return this._maxBufferPx; },\n            set: function (value) { this._maxBufferPx = coercion.coerceNumberProperty(value); },\n            enumerable: false,\n            configurable: true\n        });\n        CdkAutoSizeVirtualScroll.prototype.ngOnChanges = function () {\n            this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n        };\n        var CdkAutoSizeVirtualScroll_1;\n        __decorate([\n            core.Input(),\n            __metadata(\"design:type\", Number),\n            __metadata(\"design:paramtypes\", [Number])\n        ], CdkAutoSizeVirtualScroll.prototype, \"minBufferPx\", null);\n        __decorate([\n            core.Input(),\n            __metadata(\"design:type\", Number),\n            __metadata(\"design:paramtypes\", [Number])\n        ], CdkAutoSizeVirtualScroll.prototype, \"maxBufferPx\", null);\n        CdkAutoSizeVirtualScroll = CdkAutoSizeVirtualScroll_1 = __decorate([\n            core.Directive({\n                selector: 'cdk-virtual-scroll-viewport[autosize]',\n                providers: [{\n                        provide: scrolling.VIRTUAL_SCROLL_STRATEGY,\n                        useFactory: _autoSizeVirtualScrollStrategyFactory,\n                        deps: [core.forwardRef(function () { return CdkAutoSizeVirtualScroll_1; })],\n                    }],\n            })\n        ], CdkAutoSizeVirtualScroll);\n        return CdkAutoSizeVirtualScroll;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ScrollingModule = /** @class */ (function () {\n        function ScrollingModule() {\n        }\n        ScrollingModule = __decorate([\n            core.NgModule({\n                exports: [CdkAutoSizeVirtualScroll],\n                declarations: [CdkAutoSizeVirtualScroll],\n            })\n        ], ScrollingModule);\n        return ScrollingModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AutoSizeVirtualScrollStrategy = AutoSizeVirtualScrollStrategy;\n    exports.CdkAutoSizeVirtualScroll = CdkAutoSizeVirtualScroll;\n    exports.ItemSizeAverager = ItemSizeAverager;\n    exports.ScrollingModule = ScrollingModule;\n    exports._autoSizeVirtualScrollStrategyFactory = _autoSizeVirtualScrollStrategyFactory;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=cdk-experimental-scrolling.umd.js.map\n"]}