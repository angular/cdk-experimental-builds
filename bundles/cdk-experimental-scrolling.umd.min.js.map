{"version":3,"sources":["src/cdk-experimental/cdk-experimental-scrolling.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","cdkExperimental","scrolling","cdk","coercion","core","rxjs","this","ItemSizeAverager","defaultItemSize","_totalWeight","_defaultItemSize","_averageItemSize","prototype","getAverageItemSize","addSample","range","size","newTotalWeight","end","start","newAverageItemSize","reset","AutoSizeVirtualScrollStrategy","minBufferPx","maxBufferPx","averager","scrolledIndexChange","Observable","Error","_viewport","_removalFailures","_minBufferPx","_maxBufferPx","_averager","attach","viewport","_renderContentForCurrentOffset","detach","onContentScrolled","_updateRenderedContentAfterScroll","onDataLengthChanged","_checkRenderedContentSize","onContentRendered","onRenderedOffsetChanged","_checkRenderedContentOffset","scrollToIndex","updateBufferSize","scrollOffset","measureScrollOffset","scrollDelta","_lastScrollOffset","scrollMagnitude","Math","abs","renderedRange","getRenderedRange","offsetCorrection","predictedOffset","round","_lastRenderedContentOffset","max","min","startBuffer","endBuffer","_lastRenderedContentSize","getViewportSize","underscan","addItems","ceil","overscan","unboundedRemoveItems","floor","removeItems","_expandRange","removedSize","contentOffset","contentOffsetTo","measureRangeSize","setRenderedRange","setRenderedContentOffset","measureRenderedContentSize","_updateTotalContentSize","getOffsetToRenderedContentStart","itemSize","firstVisibleIndex","getDataLength","bufferSize","_getVisibleRangeForIndex","startIndex","extra","expandStart","expandEnd","renderedContentSize","totalSize","setTotalContentSize","_autoSizeVirtualScrollStrategyFactory","autoSizeDir","_scrollStrategy","CdkAutoSizeVirtualScroll","Object","defineProperty","get","set","value","coerceNumberProperty","enumerable","configurable","ngOnChanges","decorators","type","Directive","args","selector","providers","provide","VIRTUAL_SCROLL_STRATEGY","useFactory","deps","forwardRef","propDecorators","Input","ScrollingModule","NgModule","declarations"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/coercion'), require('@angular/cdk/scrolling'), require('@angular/core'), require('rxjs')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk-experimental/scrolling', ['exports', '@angular/cdk/coercion', '@angular/cdk/scrolling', '@angular/core', 'rxjs'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdkExperimental = global.ng.cdkExperimental || {}, global.ng.cdkExperimental.scrolling = {}), global.ng.cdk.coercion, global.ng.cdk.scrolling, global.ng.core, global.rxjs));\n}(this, (function (exports, coercion, scrolling, core, rxjs) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A class that tracks the size of items that have been seen and uses it to estimate the average\n     * item size.\n     */\n    var ItemSizeAverager = /** @class */ (function () {\n        /** @param defaultItemSize The default size to use for items when no data is available. */\n        function ItemSizeAverager(defaultItemSize) {\n            if (defaultItemSize === void 0) { defaultItemSize = 50; }\n            /** The total amount of weight behind the current average. */\n            this._totalWeight = 0;\n            this._defaultItemSize = defaultItemSize;\n            this._averageItemSize = defaultItemSize;\n        }\n        /** Returns the average item size. */\n        ItemSizeAverager.prototype.getAverageItemSize = function () {\n            return this._averageItemSize;\n        };\n        /**\n         * Adds a measurement sample for the estimator to consider.\n         * @param range The measured range.\n         * @param size The measured size of the given range in pixels.\n         */\n        ItemSizeAverager.prototype.addSample = function (range, size) {\n            var newTotalWeight = this._totalWeight + range.end - range.start;\n            if (newTotalWeight) {\n                var newAverageItemSize = (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n                if (newAverageItemSize) {\n                    this._averageItemSize = newAverageItemSize;\n                    this._totalWeight = newTotalWeight;\n                }\n            }\n        };\n        /** Resets the averager. */\n        ItemSizeAverager.prototype.reset = function () {\n            this._averageItemSize = this._defaultItemSize;\n            this._totalWeight = 0;\n        };\n        return ItemSizeAverager;\n    }());\n    /** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\n    var AutoSizeVirtualScrollStrategy = /** @class */ (function () {\n        /**\n         * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n         *     If the amount of buffer dips below this number, more items will be rendered.\n         * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n         *     If the actual amount turns out to be less it will not necessarily trigger an additional\n         *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n         * @param averager The averager used to estimate the size of unseen items.\n         */\n        function AutoSizeVirtualScrollStrategy(minBufferPx, maxBufferPx, averager) {\n            if (averager === void 0) { averager = new ItemSizeAverager(); }\n            /** @docs-private Implemented as part of VirtualScrollStrategy. */\n            this.scrolledIndexChange = new rxjs.Observable(function () {\n                // TODO(mmalerba): Implement.\n                throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n                    ' autosize scroll strategy');\n            });\n            /** The attached viewport. */\n            this._viewport = null;\n            /**\n             * The number of consecutive cycles where removing extra items has failed. Failure here means that\n             * we estimated how many items we could safely remove, but our estimate turned out to be too much\n             * and it wasn't safe to remove that many elements.\n             */\n            this._removalFailures = 0;\n            this._minBufferPx = minBufferPx;\n            this._maxBufferPx = maxBufferPx;\n            this._averager = averager;\n        }\n        /**\n         * Attaches this scroll strategy to a viewport.\n         * @param viewport The viewport to attach this strategy to.\n         */\n        AutoSizeVirtualScrollStrategy.prototype.attach = function (viewport) {\n            this._averager.reset();\n            this._viewport = viewport;\n            this._renderContentForCurrentOffset();\n        };\n        /** Detaches this scroll strategy from the currently attached viewport. */\n        AutoSizeVirtualScrollStrategy.prototype.detach = function () {\n            this._viewport = null;\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onContentScrolled = function () {\n            if (this._viewport) {\n                this._updateRenderedContentAfterScroll();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onDataLengthChanged = function () {\n            if (this._viewport) {\n                this._renderContentForCurrentOffset();\n                this._checkRenderedContentSize();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onContentRendered = function () {\n            if (this._viewport) {\n                this._checkRenderedContentSize();\n            }\n        };\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        AutoSizeVirtualScrollStrategy.prototype.onRenderedOffsetChanged = function () {\n            if (this._viewport) {\n                this._checkRenderedContentOffset();\n            }\n        };\n        /** Scroll to the offset for the given index. */\n        AutoSizeVirtualScrollStrategy.prototype.scrollToIndex = function () {\n            // TODO(mmalerba): Implement.\n            throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize'\n                + ' scroll strategy');\n        };\n        /**\n         * Update the buffer parameters.\n         * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n         * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n         *     pixels).\n         */\n        AutoSizeVirtualScrollStrategy.prototype.updateBufferSize = function (minBufferPx, maxBufferPx) {\n            if (maxBufferPx < minBufferPx) {\n                throw ('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n            }\n            this._minBufferPx = minBufferPx;\n            this._maxBufferPx = maxBufferPx;\n        };\n        /** Update the rendered content after the user scrolls. */\n        AutoSizeVirtualScrollStrategy.prototype._updateRenderedContentAfterScroll = function () {\n            var viewport = this._viewport;\n            // The current scroll offset.\n            var scrollOffset = viewport.measureScrollOffset();\n            // The delta between the current scroll offset and the previously recorded scroll offset.\n            var scrollDelta = scrollOffset - this._lastScrollOffset;\n            // The magnitude of the scroll delta.\n            var scrollMagnitude = Math.abs(scrollDelta);\n            // The currently rendered range.\n            var renderedRange = viewport.getRenderedRange();\n            // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n            // of content and the actual amount of scrollable space may differ. We address this by slowly\n            // correcting the difference on each scroll event.\n            var offsetCorrection = 0;\n            if (scrollDelta < 0) {\n                // The content offset we would expect based on the average item size.\n                var predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n                // The difference between the predicted size of the unrendered content at the beginning and\n                // the actual available space to scroll over. We need to reduce this to zero by the time the\n                // user scrolls to the top.\n                // - 0 indicates that the predicted size and available space are the same.\n                // - A negative number that the predicted size is smaller than the available space.\n                // - A positive number indicates the predicted size is larger than the available space\n                var offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n                // The amount of difference to correct during this scroll event. We calculate this as a\n                // percentage of the total difference based on the percentage of the distance toward the top\n                // that the user scrolled.\n                offsetCorrection = Math.round(offsetDifference *\n                    Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n                // Based on the offset correction above, we pretend that the scroll delta was bigger or\n                // smaller than it actually was, this way we can start to eliminate the difference.\n                scrollDelta = scrollDelta - offsetCorrection;\n                scrollMagnitude = Math.abs(scrollDelta);\n            }\n            // The current amount of buffer past the start of the viewport.\n            var startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n            // The current amount of buffer past the end of the viewport.\n            var endBuffer = (this._lastRenderedContentOffset + this._lastRenderedContentSize) -\n                (this._lastScrollOffset + viewport.getViewportSize());\n            // The amount of unfilled space that should be filled on the side the user is scrolling toward\n            // in order to safely absorb the scroll delta.\n            var underscan = scrollMagnitude + this._minBufferPx -\n                (scrollDelta < 0 ? startBuffer : endBuffer);\n            // Check if there's unfilled space that we need to render new elements to fill.\n            if (underscan > 0) {\n                // Check if the scroll magnitude was larger than the viewport size. In this case the user\n                // won't notice a discontinuity if we just jump to the new estimated position in the list.\n                // However, if the scroll magnitude is smaller than the viewport the user might notice some\n                // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n                // the same number of pixels as the scroll magnitude.\n                if (scrollMagnitude >= viewport.getViewportSize()) {\n                    this._renderContentForCurrentOffset();\n                }\n                else {\n                    // The number of new items to render on the side the user is scrolling towards. Rather than\n                    // just filling the underscan space, we actually fill enough to have a buffer size of\n                    // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n                    var addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\n                        this._averager.getAverageItemSize()));\n                    // The amount of filled space beyond what is necessary on the side the user is scrolling\n                    // away from.\n                    var overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx +\n                        scrollMagnitude;\n                    // The number of currently rendered items to remove on the side the user is scrolling away\n                    // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n                    // remove.\n                    var unboundedRemoveItems = Math.floor(overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n                    var removeItems = Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n                    // The new range we will tell the viewport to render. We first expand it to include the new\n                    // items we want rendered, we then contract the opposite side to remove items we no longer\n                    // want rendered.\n                    var range = this._expandRange(renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n                    if (scrollDelta < 0) {\n                        range.end = Math.max(range.start + 1, range.end - removeItems);\n                    }\n                    else {\n                        range.start = Math.min(range.end - 1, range.start + removeItems);\n                    }\n                    // The new offset we want to set on the rendered content. To determine this we measure the\n                    // number of pixels we removed and then adjust the offset to the start of the rendered\n                    // content or to the end of the rendered content accordingly (whichever one doesn't require\n                    // that the newly added items to be rendered to calculate.)\n                    var contentOffset = void 0;\n                    var contentOffsetTo = void 0;\n                    if (scrollDelta < 0) {\n                        var removedSize = viewport.measureRangeSize({\n                            start: range.end,\n                            end: renderedRange.end,\n                        });\n                        // Check that we're not removing too much.\n                        if (removedSize <= overscan) {\n                            contentOffset =\n                                this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n                            this._removalFailures = 0;\n                        }\n                        else {\n                            // If the removal is more than the overscan can absorb just undo it and record the fact\n                            // that the removal failed so we can be less aggressive next time.\n                            range.end = renderedRange.end;\n                            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n                            this._removalFailures++;\n                        }\n                        contentOffsetTo = 'to-end';\n                    }\n                    else {\n                        var removedSize = viewport.measureRangeSize({\n                            start: renderedRange.start,\n                            end: range.start,\n                        });\n                        // Check that we're not removing too much.\n                        if (removedSize <= overscan) {\n                            contentOffset = this._lastRenderedContentOffset + removedSize;\n                            this._removalFailures = 0;\n                        }\n                        else {\n                            // If the removal is more than the overscan can absorb just undo it and record the fact\n                            // that the removal failed so we can be less aggressive next time.\n                            range.start = renderedRange.start;\n                            contentOffset = this._lastRenderedContentOffset;\n                            this._removalFailures++;\n                        }\n                        contentOffsetTo = 'to-start';\n                    }\n                    // Set the range and offset we calculated above.\n                    viewport.setRenderedRange(range);\n                    viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n                }\n            }\n            else if (offsetCorrection) {\n                // Even if the rendered range didn't change, we may still need to adjust the content offset to\n                // simulate scrolling slightly slower or faster than the user actually scrolled.\n                viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n            }\n            // Save the scroll offset to be compared to the new value on the next scroll event.\n            this._lastScrollOffset = scrollOffset;\n        };\n        /**\n         * Checks the size of the currently rendered content and uses it to update the estimated item size\n         * and estimated total content size.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._checkRenderedContentSize = function () {\n            var viewport = this._viewport;\n            this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n            this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n            this._updateTotalContentSize(this._lastRenderedContentSize);\n        };\n        /** Checks the currently rendered content offset and saves the value for later use. */\n        AutoSizeVirtualScrollStrategy.prototype._checkRenderedContentOffset = function () {\n            var viewport = this._viewport;\n            this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart();\n        };\n        /**\n         * Recalculates the rendered content based on our estimate of what should be shown at the current\n         * scroll offset.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._renderContentForCurrentOffset = function () {\n            var viewport = this._viewport;\n            var scrollOffset = viewport.measureScrollOffset();\n            this._lastScrollOffset = scrollOffset;\n            this._removalFailures = 0;\n            var itemSize = this._averager.getAverageItemSize();\n            var firstVisibleIndex = Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n            var bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n            var range = this._expandRange(this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n            viewport.setRenderedRange(range);\n            viewport.setRenderedContentOffset(itemSize * range.start);\n        };\n        // TODO: maybe move to base class, can probably share with fixed size strategy.\n        /**\n         * Gets the visible range of data for the given start index. If the start index is too close to\n         * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n         * fill the viewport.\n         * Note: must not be called if `this._viewport` is null\n         * @param startIndex The index to start the range at\n         * @return a range estimated to be large enough to fill the viewport when rendered.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._getVisibleRangeForIndex = function (startIndex) {\n            var viewport = this._viewport;\n            var range = {\n                start: startIndex,\n                end: startIndex +\n                    Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize())\n            };\n            var extra = range.end - viewport.getDataLength();\n            if (extra > 0) {\n                range.start = Math.max(0, range.start - extra);\n            }\n            return range;\n        };\n        // TODO: maybe move to base class, can probably share with fixed size strategy.\n        /**\n         * Expand the given range by the given amount in either direction.\n         * Note: must not be called if `this._viewport` is null\n         * @param range The range to expand\n         * @param expandStart The number of items to expand the start of the range by.\n         * @param expandEnd The number of items to expand the end of the range by.\n         * @return The expanded range.\n         */\n        AutoSizeVirtualScrollStrategy.prototype._expandRange = function (range, expandStart, expandEnd) {\n            var viewport = this._viewport;\n            var start = Math.max(0, range.start - expandStart);\n            var end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n            return { start: start, end: end };\n        };\n        /** Update the viewport's total content size. */\n        AutoSizeVirtualScrollStrategy.prototype._updateTotalContentSize = function (renderedContentSize) {\n            var viewport = this._viewport;\n            var renderedRange = viewport.getRenderedRange();\n            var totalSize = renderedContentSize +\n                (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n                    this._averager.getAverageItemSize();\n            viewport.setTotalContentSize(totalSize);\n        };\n        return AutoSizeVirtualScrollStrategy;\n    }());\n    /**\n     * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n     * `AutoSizeVirtualScrollStrategy` from the given directive.\n     * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n     *     `AutoSizeVirtualScrollStrategy` from.\n     */\n    function _autoSizeVirtualScrollStrategyFactory(autoSizeDir) {\n        return autoSizeDir._scrollStrategy;\n    }\n    /** A virtual scroll strategy that supports unknown or dynamic size items. */\n    var CdkAutoSizeVirtualScroll = /** @class */ (function () {\n        function CdkAutoSizeVirtualScroll() {\n            this._minBufferPx = 100;\n            this._maxBufferPx = 200;\n            /** The scroll strategy used by this directive. */\n            this._scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n        }\n        Object.defineProperty(CdkAutoSizeVirtualScroll.prototype, \"minBufferPx\", {\n            /**\n             * The minimum amount of buffer rendered beyond the viewport (in pixels).\n             * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n             */\n            get: function () { return this._minBufferPx; },\n            set: function (value) { this._minBufferPx = coercion.coerceNumberProperty(value); },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(CdkAutoSizeVirtualScroll.prototype, \"maxBufferPx\", {\n            /**\n             * The number of pixels worth of buffer to shoot for when rendering new items.\n             * If the actual amount turns out to be less it will not necessarily trigger an additional\n             * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n             * Defaults to 200px.\n             */\n            get: function () { return this._maxBufferPx; },\n            set: function (value) { this._maxBufferPx = coercion.coerceNumberProperty(value); },\n            enumerable: false,\n            configurable: true\n        });\n        CdkAutoSizeVirtualScroll.prototype.ngOnChanges = function () {\n            this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n        };\n        CdkAutoSizeVirtualScroll.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'cdk-virtual-scroll-viewport[autosize]',\n                        providers: [{\n                                provide: scrolling.VIRTUAL_SCROLL_STRATEGY,\n                                useFactory: _autoSizeVirtualScrollStrategyFactory,\n                                deps: [core.forwardRef(function () { return CdkAutoSizeVirtualScroll; })],\n                            }],\n                    },] }\n        ];\n        CdkAutoSizeVirtualScroll.propDecorators = {\n            minBufferPx: [{ type: core.Input }],\n            maxBufferPx: [{ type: core.Input }]\n        };\n        return CdkAutoSizeVirtualScroll;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ScrollingModule = /** @class */ (function () {\n        function ScrollingModule() {\n        }\n        ScrollingModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: [CdkAutoSizeVirtualScroll],\n                        declarations: [CdkAutoSizeVirtualScroll],\n                    },] }\n        ];\n        return ScrollingModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AutoSizeVirtualScrollStrategy = AutoSizeVirtualScrollStrategy;\n    exports.CdkAutoSizeVirtualScroll = CdkAutoSizeVirtualScroll;\n    exports.ItemSizeAverager = ItemSizeAverager;\n    exports.ScrollingModule = ScrollingModule;\n    exports._autoSizeVirtualScrollStrategyFactory = _autoSizeVirtualScrollStrategyFactory;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=cdk-experimental-scrolling.umd.js.map\n"]}